# Learning Domain-Driven Design

## 1. ビジネスドメインを分析する

ビジネスドメインとは、**会社の主たる活動領域**のこと。複数の場合もある。
例えば、Fedexなら運送、スタバなら飲食、ウォルマートなら小売。

ドメインの目標を達成するために、複数の**サブドメイン**が構成される。
例えば、スタバならコーヒー製造、物流、不動産、人事、金融など。

サブドメインは、Core, Generic, and Supporting の3種類がある。

- **Core Subdomains**
  - ビジネス固有かつ複雑な領域
  - 金を生む
  - 競争力になる
  - 他社に対する参入障壁として機能する
  - 頻繁に変更される
  - 技術によるものとは限らず、人によるものの場合もある
  - e.g. 宝石屋ならデザイン部門
- **Generic Subdomains**
  - ビジネス固有ではないが複雑な領域
  - ビジネス固有ではないので、既成のソリューションがあり、競争力にはならない
  - "Known unknowns"の領域
  - e.g. ユーザーの認証システムなど
- **Supporting Subdomains**
  - ビジネス固有かつシンプルな領域
  - ビジネス固有なので、既製品はない
  - シンプルなので、競争力にはならない
  - リソースを割いてもしょうがない領域であり、アウトソース候補である
  - ETLやCRUDのようなインターフェースを取ることが多い

サブドメインの発見は、ユースケースを基準に行うとよい。
特定のアクターが、一定の範囲のデータとそれに対応するユースケース群を使って、
業務フローを完結できる単位が、一つのサブドメインと言える。

**ドメインエキスパート**とは、ビジネスルールとプロセスを知っている人のこと。
ソフトウェアで問題を解決してあげる対象者であり、エンドユーザーともいえる。

## 2. ドメイン知識を発見する

### 問題

ビジネスにおける**問題**とは、簡単に解けるクイズのようなものではなく、
もっと幅広い意味を持つものだ。例えば以下のようなものがある。

- 非効率なワークフロー
- 人の手がかかる高コスト作業
- リソースの非効率的な分配
- 意思決定のための情報の不足
- 大量のデータの管理

これらの問題にソリューションを提供するのが、ビジネスの目的である。
コードを書くという作業は枝葉の話である。成功に必要なのは**問題の理解**である。

### ユビキタス言語

従来、問題からソリューションまでの道は「ドメイン知識->分析モデル->仕様->システム設計->実装」のような流れだった。
これは**一方通行的**であり、開発者と現場の相互の意見交換がないので、問題理解が浅いままになりがち。
また、多くの**変換**の過程で情報が失われたり陳腐化したりする。
結果として的はずれな解決策が生まれる。

それよりも、あらゆる関係者が**ユビキタス言語**を使うべきだ。

ユビキタス言語とは、ドメインエキスパートのビジネスドメインに対する理解とメンタルモデルを、
**技術の言葉ではなくビジネスの言葉で表現**したものである。
あらゆる関係者がユビキタス言語を使えば、問題理解が促進され、変換も不要になる。

ユビキタス言語は全ての関係者が使うべきだし、
あらゆる場所（会話、文書、テスト、図、コード）で使うべきである。
これを守るのが一番大事で、忍耐と監視が必要。

1つの言葉は1つの概念をきっちり表すものでなければならない。
曖昧な言葉は、より具体的な複数の定義に分けよう。
似たような言葉は、コンテキストを意識して明確に使い分けるか、もしくは統合しよう。

### モデル

**モデル**とは現実世界の要素を簡略化・抽象化して表現したもの。
モデルは特定の目的や問題解決(≒システム)のために作られる。

なので、モデルが単に現実世界のコピーになってはダメであり、
目的達成のために必要となる情報を過不足なく得られるよう、
現実世界の要素を取捨選択しながら作る必要がある。
例えば地図でいうと、目的に応じて世界地図、電車路線図、測量図など様々なモデルがあるように。

ユビキタス言語は、**ドメインエキスパートのメンタルモデルを捉えるためのモデル**といえる。

ユビキタス言語は継続的に進化していくべきものであり、ツールの活用は大事。
「名詞」の管理、つまり用語集をつくるにはwikiを使うと良い。英語の定義は必須で、必要に応じて他言語でも定義する。
「動詞」の管理、つまりシナリオの管理には[Gherkin](https://cucumber.io/docs/gherkin/reference/)を書いて管理すると良い。

```gherkin
Feature: 書籍の貸出
  図書館員が利用者に書籍を貸し出すことができる

    Background:
      Given 図書館システムが稼働している

    Scenario: 通常の貸出
      Given 会員 "山田" の貸出冊数が 2冊
      And 書籍 "吾輩は猫である" が貸出可能
      When 山田に貸し出す
      Then 貸出が完了する
      And 山田の貸出冊数が 3冊になる
      And 書籍が "貸出中" になる

    Scenario: 貸出上限エラー
      Given 会員 "鈴木" の貸出冊数が 5冊（上限）
      And 書籍 "坊っちゃん" が貸出可能
      When 鈴木に貸し出そうとする
      Then "貸出上限に達しています" とエラーになる
      And 貸出冊数は変わらない
```

大事な知識はドメインエキスパートの頭の中にしかなかったりするので、モデルを作るのは厳しい道だ。
とにかく質問をする以外に近道はない。これは発見というよりは共創のプロセスであるとみんなで認識しよう。

## 3. ドメインの複雑さと戦う

### Bounded Contexts とモデル

ビジネスが大きくなると、同じ言葉がコンテキストによって違う意味を持つ場合がある。
あらゆる場所で使える巨大な言葉を定義したり、言葉にプレフィックスを付けたりする解決法もあるが、うまくいかないことが多い。

こういうときは **Bounded Contexts** を作る。

実は、モデル(=ユビキタス言語、つまり語彙や原理やビジネスルール)はBounded Contextの中にしか存在し得ない。
特定の問題を解決するために境界を作り、その目的を意識しながらドメインをモデル化することで、初めてモデルは意味を持つ。
境界がなければモデルはただの現実世界のコピーになってしまい、なんの役にもたたなくなる。

「ユビキタス」とは社内のあらゆる場所で使われるべきという意味であり、
どんなコンテキストでも使える「ユニバーサル」ではないのだ。

Bounded Context が現実世界のどこに存在するかというと、ドメインエキスパートの心の中である(!)。

### サブドメインとBounded Contexts

サブドメインは**発見**するものである。企業の戦略で決まり、開発者の範疇の外にある。

一方、Bounded Context(これはユビキタス言語というモデルのスコープでもある)は、**デザイン**するものである。
戦略的な判断により適切に決める。

Contextは必ずしもサブドメインと**1-1で結びつかなくてもいい**。
小さいシステムなら全てのサブドメインを一つのContextで対処することもできる。
もしモデルがコンフリクトするようであれば、コンテキストを分割していくべきだろう。
また、ある1つのサブドメインにおいて問題のバリエーションが多い場合は、
1つのサブドメインに対して複数のContextを同時に割り当てることもある。

Contextの範囲は小さいほうがモデルの一貫性を保ちやすく、管理しやしく、スケールアウトしやすい。
一方で、同じデータを扱うユースケースが複数のContextに分断されると効率が落ちる。

### 境界の役割

アーキテクチャデザインとは、つまるところ境界を決めることである。
何が含まれ、何が除外され、何が境界を跨ぎ、何がその間を行き来するか、を明らかにすることだ。

Bounded Context は**物理境界**である。
つまり、独自に進化が可能で、コード・デプロイ・バージョン管理などは完全に独立している。
service, subsystem といった手法で分離される。

Bounded Contextは **所有境界** でもある。
1つのチームだけで管理されるべきであり、2つ以上のチームで共有はできない。

Bounded Context の中に複数のサブドメインが含まれる場合、
それらサブドメイン間の境界は**論理境界**となる。
namespace, module, package といった手法で分離される。

## 4. Bounded Context を組み合わせる

複数のBounded Contextsの間でのコミュニケーションにおける、
取り決めや約束事を **Contracts** と呼ぶ。
そのスタイルにはいくつかの種類がある。

### Cooperation

1つのチームが複数のContextを管理していたり、2つのチームが共通のゴールを共有しており、
密なコミュニケーションがとれる場合には、Cooperationが選択できる。

**Partnership**は、APIに変更があったときにチーム間で連絡し合って、都度調整する方法。
素朴でシンプルだが、チーム間で極めて頻繁かつ同期的なコミュニケーションが必要である。

**Shared Kernel**は、複数のContextで同じモデルを使用すること。
コードが重複することの弊害が、コードを共有することで発生する調整コストよりも大きい場合に使用を検討する。
変更を加えたら自動でCIが実行され、即時に全てのContextに反映されるようにする。
影響を小さくするため、モデル化の範囲は必要最小限とすべき。
代表的なユースケースとしては以下がある。

- 地理的に離れたチームなのでPartnershipを採用できないとき
- レガシーシステムの近代化の過程での一時的な構成として
- 単一チームで複数のContextを扱うときに、あえて境界を明確化するため (単一チームでPartnershipを採用すると境界が曖昧になりがち)

### Customer-Supplier

Upstream(supplier)とDownstream(customer)を定義し、
それぞれ独立して開発できるようにする方法。
パワーバランスに差があるのが特徴。

**Comformist**は、upstreamが決めた形式にdownstreamが適合(Conform)する方法。
外部サービスを利用する場合などに取るパターン。
upstream側が業界標準形式のデータを提供していたり、
洗練されたモデルを提供していて、それをそのまま使いたい場合に最適。

モデルをそのまま使うのではなく変換したい場合は、**Anticorruption Layer**を使う。
upstreamの頻繁な変更が直接影響しないようにすることで、downstreamのモデルを守るのが目的。
不要なものを削ったり、Contextで使いやすくしたりする。

逆に、upstream側で公開するデータの形式に気を配る方法を**Open-Host Service**と呼ぶ。
モデルを独立して進化させつつ、downstreamへの影響を最小限に抑えるのが目的。
Anticorruption Layerの逆バージョンと言える。
モデルを直接公開せず、Published Languageと呼ばれる、customer向けに最適化された別の形式に変換して公開する。
Published Languageをバージョニングすることで、customerに対する破壊的変更をなくすことも可能。

### Separate Ways

場合によっては**協調しない**という選択もある。

組織サイズや社内政治により**コミュニケーションが難しい場合**は、
コードが重複したとしても、別々に開発したほうが効率的なこともある。

また、**Generic Subdomains**については既成のソリューションがあるので、
無理にコンテキストを作ってサービスを公開して協調コストを上げるよりも、
単に外部サービスを各Contextが独立して利用するほうが効率的なこともある。
代表例は、認証認可、通知サービス、支払い、ストレージ、ログなど。

**モデルが根本的に異なりすぎる場合**も、あえて別々の道を歩む選択肢をとりうる。
適合どころか腐敗防止層を構築するコストすら高すぎる場合などだ。
こういうときはコードの重複を許容してでも独立性を保つ方が合理的な判断となることがある。

ただし、**Core Subdomain に Separate Ways を採用するのはダメ**だ。
これをやってしまうと会社の成長の足を引っ張ることになる。

### Context Map

コンテキスト間の関係性を図にしたもの。作ると以下のメリットがある。

- システムのコンポーネントとモデルを俯瞰できる
- 必要なコミュニケーションのパターンを知ることができる(密に連携が必要 or あまり連携は必要ない)
- 組織の問題を発見できる（なぜこのチームの利用者は全て腐敗防止層を作らなければいけない？意思疎通できてる？とか）
