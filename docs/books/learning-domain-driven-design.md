# Learning Domain-Driven Design / ドメイン駆動設計をはじめよう

## 1. ビジネスドメインを分析する

ビジネスドメインとは、**会社の主たる活動領域**のこと。複数の場合もある。
例えば、Fedexなら運送、スタバなら飲食、ウォルマートなら小売。

ドメインの目標を達成するために、複数の**サブドメイン**が構成される。
例えば、スタバならコーヒー製造、物流、不動産、人事、金融など。

サブドメインは、Core, Generic, and Supporting の3種類がある。

- **Core Subdomains**
  - ビジネス固有かつ複雑な領域
  - 金を生む
  - 競争力になる
  - 他社に対する参入障壁として機能する
  - 頻繁に変更される
  - 技術によるものとは限らず、人によるものの場合もある
  - e.g. 宝石屋ならデザイン部門
- **Generic Subdomains**
  - ビジネス固有ではないが複雑な領域
  - ビジネス固有ではないので、既成のソリューションがあり、競争力にはならない
  - "Known unknowns"の領域
  - e.g. ユーザーの認証システムなど
- **Supporting Subdomains**
  - ビジネス固有かつシンプルな領域
  - ビジネス固有なので、既製品はない
  - シンプルなので、競争力にはならない
  - リソースを割いてもしょうがない領域であり、アウトソース候補である
  - ETLやCRUDのようなインターフェースを取ることが多い

サブドメインの発見は、ユースケースを基準に行うとよい。
特定のアクターが、一定の範囲のデータとそれに対応するユースケース群を使って、
業務フローを完結できる単位が、一つのサブドメインと言える。

**ドメインエキスパート**とは、ビジネスルールとプロセスを知っている人のこと。
ソフトウェアで問題を解決してあげる対象者であり、エンドユーザーともいえる。

## 2. ドメイン知識を発見する

### 問題

ビジネスにおける**問題**とは、簡単に解けるクイズのようなものではなく、
もっと幅広い意味を持つものだ。例えば以下のようなものがある。

- 非効率なワークフロー
- 人の手がかかる高コスト作業
- リソースの非効率的な分配
- 意思決定のための情報の不足
- 大量のデータの管理

これらの問題にソリューションを提供するのが、ビジネスの目的である。
コードを書くという作業は枝葉の話である。成功に必要なのは**問題の理解**である。

### ユビキタス言語

従来、問題からソリューションまでの道は「ドメイン知識->分析モデル->仕様->システム設計->実装」のような流れだった。
これは**一方通行的**であり、開発者と現場の相互の意見交換がないので、問題理解が浅いままになりがち。
また、多くの**変換**の過程で情報が失われたり陳腐化したりする。
結果として的はずれな解決策が生まれる。

それよりも、あらゆる関係者が**ユビキタス言語**を使うべきだ。

ユビキタス言語とは、ドメインエキスパートのビジネスドメインに対する理解とメンタルモデルを、
**技術の言葉ではなくビジネスの言葉で表現**したものである。
あらゆる関係者がユビキタス言語を使えば、問題理解が促進され、変換も不要になる。

ユビキタス言語は全ての関係者が使うべきだし、
あらゆる場所（会話、文書、テスト、図、コード）で使うべきである。
これを守るのが一番大事で、忍耐と監視が必要。

1つの言葉は1つの概念をきっちり表すものでなければならない。
曖昧な言葉は、より具体的な複数の定義に分けよう。
似たような言葉は、コンテキストを意識して明確に使い分けるか、もしくは統合しよう。

### モデル

**モデル**とは現実世界の要素を簡略化・抽象化して表現したもの。
モデルは特定の目的や問題解決(≒システム)のために作られる。

なので、モデルが単に現実世界のコピーになってはダメであり、
目的達成のために必要となる情報を過不足なく得られるよう、
現実世界の要素を取捨選択しながら作る必要がある。
例えば地図でいうと、目的に応じて世界地図、電車路線図、測量図など様々なモデルがあるように。

ユビキタス言語は、**ドメインエキスパートのメンタルモデルを捉えるためのモデル**といえる。

ユビキタス言語は継続的に進化していくべきものであり、ツールの活用は大事。
「名詞」の管理、つまり用語集をつくるにはwikiを使うと良い。英語の定義は必須で、必要に応じて他言語でも定義する。
「動詞」の管理、つまりシナリオの管理には[Gherkin](https://cucumber.io/docs/gherkin/reference/)を書いて管理すると良い。

```gherkin
Feature: 書籍の貸出
  図書館員が利用者に書籍を貸し出すことができる

    Background:
      Given 図書館システムが稼働している

    Scenario: 通常の貸出
      Given 会員 "山田" の貸出冊数が 2冊
      And 書籍 "吾輩は猫である" が貸出可能
      When 山田に貸し出す
      Then 貸出が完了する
      And 山田の貸出冊数が 3冊になる
      And 書籍が "貸出中" になる

    Scenario: 貸出上限エラー
      Given 会員 "鈴木" の貸出冊数が 5冊（上限）
      And 書籍 "坊っちゃん" が貸出可能
      When 鈴木に貸し出そうとする
      Then "貸出上限に達しています" とエラーになる
      And 貸出冊数は変わらない
```

大事な知識はドメインエキスパートの頭の中にしかなかったりするので、モデルを作るのは厳しい道だ。
とにかく質問をする以外に近道はない。これは発見というよりは共創のプロセスであるとみんなで認識しよう。

## 3. ドメインの複雑さと戦う

### Bounded Contexts とモデル

ビジネスが大きくなると、同じ言葉がコンテキストによって違う意味を持つ場合がある。
あらゆる場所で使える巨大な言葉を定義したり、言葉にプレフィックスを付けたりする解決法もあるが、うまくいかないことが多い。

こういうときは **Bounded Contexts** を作る。

実は、モデル(=ユビキタス言語、つまり語彙や原理やビジネスルール)はBounded Contextの中にしか存在し得ない。
特定の問題を解決するために境界を作り、その目的を意識しながらドメインをモデル化することで、初めてモデルは意味を持つ。
境界がなければモデルはただの現実世界の完全コピーになってしまい、なんの役にもたたない代物になる。

「ユビキタス」とは、あくまで社内のあらゆる場所で使われるべきという意味であり、
どんなコンテキストでも使える「ユニバーサル」という意味ではないのだ。

Bounded Context が現実世界のどこに存在するかというと、ドメインエキスパートの心の中である(!)。

### サブドメインとBounded Contexts

サブドメインは**発見**するものである。企業の戦略で決まり、開発者の範疇の外にある。

一方、Bounded Context(これはユビキタス言語というモデルのスコープでもある)は、**デザイン**するものである。
戦略的な判断により適切に決める。

Contextは必ずしもサブドメインと**1-1で結びつかなくてもいい**。
小さいシステムなら全てのサブドメインを一つのContextで対処することもできる。
もしモデルがコンフリクトするようであれば、コンテキストを分割していくべきだろう。
また、ある1つのサブドメインにおいて問題のバリエーションが多い場合は、
1つのサブドメインに対して複数のContextを同時に割り当てることもある。

Contextの範囲は小さいほうがモデルの一貫性を保ちやすく、管理しやしく、スケールアウトしやすい。
一方で、同じデータを扱うユースケースが複数のContextに分断されると効率が落ちる。

### 境界の役割

アーキテクチャデザインとは、つまるところ境界を決めることである。
何が含まれ、何が除外され、何が境界を跨ぎ、何がその間を行き来するかを明らかにすることだ。

Bounded Context は**物理境界**である。
つまり、独自に進化が可能で、コード・デプロイ・バージョン管理などは完全に独立している。
service, subsystem といった手法で分離される。

Bounded Contextは **所有境界** でもある。
1つのチームだけで管理されるべきであり、2つ以上のチームで共有はできない。

Bounded Context の中に複数のサブドメインが含まれる場合、
それらサブドメイン間の境界は**論理境界**となる。
namespace, module, package といった手法で分離される。

## 4. Bounded Context を組み合わせる

複数のBounded Contextsの間でのコミュニケーションにおける、
取り決めや約束事を **Contracts** と呼ぶ。
そのスタイルにはいくつかの種類がある。

### Cooperation

1つのチームが複数のContextを管理していたり、2つのチームが共通のゴールを共有しており、
密なコミュニケーションがとれる場合には、Cooperationが選択できる。

**Partnership**は、APIに変更があったときにチーム間で連絡し合って、都度調整する方法。
素朴でシンプルだが、チーム間で極めて頻繁かつ同期的なコミュニケーションが必要である。

**Shared Kernel**は、複数のContextで同じモデルを使用すること。
コードが重複することの弊害が、コードを共有することで発生する調整コストよりも大きい場合に使用を検討する。
変更を加えたら自動でCIが実行され、即時に全てのContextに反映されるようにする。
影響を小さくするため、モデル化の範囲は必要最小限とすべき。
代表的なユースケースとしては以下がある。

- 地理的に離れたチームなのでPartnershipを採用できないとき
- レガシーシステムの近代化の過程での一時的な構成として
- 単一チームで複数のContextを扱うときに、あえて境界を明確化するため (単一チームでPartnershipを採用すると境界が曖昧になりがち)

### Customer-Supplier

Upstream(supplier)とDownstream(customer)を定義し、
それぞれ独立して開発できるようにする方法。
パワーバランスに差があるのが特徴。

**Comformist**は、upstreamが決めた形式にdownstreamが適合(Conform)する方法。
外部サービスを利用する場合などに取るパターン。
upstream側が業界標準形式のデータを提供していたり、
洗練されたモデルを提供していて、それをそのまま使いたい場合に最適。

モデルをそのまま使うのではなく変換したい場合は、**Anticorruption Layer**を使う。
upstreamの頻繁な変更が直接影響しないようにすることで、downstreamのモデルを守るのが目的。
不要なものを削ったり、Contextで使いやすくしたりする。

逆に、upstream側で公開するデータの形式に気を配る方法を**Open-Host Service**と呼ぶ。
モデルを独立して進化させつつ、downstreamへの影響を最小限に抑えるのが目的。
Anticorruption Layerの逆バージョンと言える。
モデルを直接公開せず、Published Languageと呼ばれる、customer向けに最適化された別の形式に変換して公開する。
Published Languageをバージョニングすることで、customerに対する破壊的変更をなくすことも可能。

### Separate Ways

場合によっては**協調しない**という選択もある。

組織サイズや社内政治により**コミュニケーションが難しい場合**は、
コードが重複したとしても、別々に開発したほうが効率的なこともある。

また、**Generic Subdomains**については既成のソリューションがあるので、
無理に自前でContextを作って協調コストを上げるよりも、
単にそれぞれのContextが外部サービスを直接利用するほうが効率的なこともある。
代表例は、認証認可、通知サービス、支払い、ストレージ、ログなど。

**モデルが根本的に異なりすぎる場合**も、あえて別々の道を歩む選択肢をとりうる。
適合どころか腐敗防止層を構築するコストすら高すぎる場合などだ。
こういうときはコードの重複を許容してでも独立性を保つ方が合理的な判断となることがある。

ただし、**Core Subdomain に Separate Ways を採用するのはダメ**だ。
これをやってしまうと会社の成長の足を引っ張ることになる。

### Context Map

コンテキスト間の関係性を図にしたもの。作ると以下のメリットがある。

- システムのコンポーネントとモデルを俯瞰できる
- 必要なコミュニケーションのパターンを知ることができる(密に連携が必要 or あまり連携は必要ない)
- 組織の問題を発見できる（なぜこのチームの利用者は全て腐敗防止層を作らなければいけない？意思疎通できてる？とか）

## 5. シンプルなロジックの実装手法

### Transaction Script

単純に手続きを順に書いていくやり方。DBに直接アクセスできる。
必ず成功か失敗のいずれかの結果になる必要があり、中途半端な状態になってはいけない。
より洗練された書き方の基礎となる書き方である。

一番のメリットはその**シンプルさ**である。理解しやすくパフォーマンスも良い。
一方で、ロジックが複雑になるとすぐにコードが重複して管理が難しくなり、一貫性のない挙動を生みがち。

ETLのような、ロジックがシンプルなSupporting Domainに最適。
Core Domainに使われるべきではない。

### Active Record

Active Recordと呼ばれるオブジェクトに、データ構造と、
そのデータ構造にアクセスするためのCRUDメソッドを持たせたうえで、処理を書いていく方法。
書き方は本質的にトランザクションスクリプトと同じ。

このパターンのメリットは、**複雑なデータ構造をDBにマッピングする際の複雑さを隠蔽**できることだ。
また、バリデーションなどのビジネスロジックを持たせられることだ。
とはいえ、複雑なロジックはActive Recordの外に書かれることが多い。

ロジックはシンプルだがデータ構造が複雑なものに最適といえる。例えば以下のようなものだ。

- CRUD処理しかしないSupporting Domain
- Generic Domainにおける外部サービスの組み込み
- モデルの相互変換処理

Activeとは能動的の意味で、Record自身がデータベース操作を実行するためによう呼ばれている。
必然的にORMなどと一体化している。
アンチパターンと言われることもあるが、適切な場所で使うのは全く問題ないどころか効果的である。

## 6. 複雑なロジックの実装手法

### Domain Model Pattern

複雑なドメインに対しては**ドメインモデルパターン**が利用できる。

ドメインモデルとは、振る舞いとデータの両方を組み込んだモデルのこと。
ドメインモデルは**プレーンなオブジェクト**として実装する。
また、インフラ層は分離して直接依存しない形で実装する。
なぜなら、ドメインはもともと複雑なので、本質でない部分により偶発的な複雑さを持ち込む余裕はないからだ。
また、技術詳細が隔離されることで、ドメイン層でユビキタス言語を喋らせるのが容易になるからだ。

ドメインモデルを組み上げるためのパーツとなるのが、値オブジェクト、集約、ドメインサービスの3つである。
(エンティティは集約の一部に過ぎないからあえてここに含めない)

### 構成要素

**値オブジェクト**は、値によってのみ識別される概念であり、IDフィールドを必要としない。
一つでもプロパティを変更するときは、新しいオブジェクトを返す(イミュータブルにする)。
stringやnumberなどの代わりに使うことで、コードの意図が伝わりやすくなる。
また、バリデーションを確実にシンプルに実行できる(ユビキタス言語を表現できる)。
使えそうな場所ではどんどん使おう。

**エンティティ**は値オブジェクトと逆で、識別にIDが必要なもの。
例えば人は、名前だけでは識別できないよね。
変更が行われることが想定される、ミュータブルなオブジェクトである。
独立して実装されることはなく、必ず集約の一部として実装される。

**集約**は単一または複数のエンティティから構成される、**一貫性を担保するための境界**である。
集約の内部状態は、その公開APIを介してのみ変更が可能であり、常に正しい状態が保たれる。
公開APIはしばしば**Commands**と呼ばれる。

集約では同時更新を防ぐため、必ず**Concurrency Management**が必要。
例えば、更新時にバージョン番号が一致しているかを確認してから更新するなど。

集約は**トランザクション境界**でもある。
一貫性を保つためには一部だけが更新されることがあってはならないからだ。
さらに、1つのトランザクションで複数の集約を更新すべきではない。
そうしたくなるとしたら、それは集約の境界を間違って設計しているシグナルだ。

強い一貫性が必要なエンティティだけを同一の集約に含め、それ以外は別の集約として定義したうえで**結果整合性**で済ませる。
他の集約への参照は、オブジェクトそのものではなくIDで行う。
強い一貫性が必要かどうかは、「もしそのデータが実際よりも遅れていた場合に問題がおきるか？」で判断する。

集約のエンティティの階層を持ち、このうち1つだけが外部公開APIを持つ。
このエンティティを**Aggregate Root**と呼ぶ。

集約の名前、データ属性、メソッド、ドメインイベントなどは、**全てユビキタス言語で命名**されなければならない。
これは複雑なシステムを作成する際には極めて重要な指針である。

**Domain Events**とは、ビジネスドメインで発生したイベントを説明するメッセージである。
集約の外部インターフェースの一部であり、後段のコンポーネントが購読して次の処理を実行するきっかけとなる。
`Ticked assigned`や`Message received`などの過去形で表現されたメッセージと、
理由、日時や処理したデータなど、後段で必要となるすべての情報で構成される。

**Domain Services**は、ビジネスロジックを持つステートレスで単純なオブジェクトだ。
複数の集約の**読み取り**をしたのちに何らかの計算や分析を行うロジックを記述する。
更新向きではなく、まして1つのトランザクションで複数の集約を更新することが特別に許された場所でもない。
なお、サービスという言葉とは裏腹に、サービスっぽいことはなにもしない。

### なぜ複雑さを減らせるのか

システムの複雑さを決める要素の一つに、**Degrees of freedom** (自由度)がある。
これは、システムが「どれだけ多くの異なる状態になれるか」といえる。
選択肢が多いほど、予測や制御が困難になり、相互作用が指数爆発し、
より多くのデータや計算が必要になるからだ。

集約や値オブジェクトは、ビジネスが守るべき**不変条件をカプセル化することで自由度を減らしている**。
不変条件を手続き的にあちこちに書いていくと、次第に自由度が高まっていき、いずれ複雑さに対処できなくなる。

(Abstract Data Typeも、Repository Patternも、Domain Modelも、Fluxも、State Machineも、
どれも自由度を減らして複雑さと戦うための手法と言える)
