# Effective TypeScript

## 1. TS と JS の関係を知る

- TS は JS のスーパーセット。JS のコードは TS のコードとして使える。
- TS は静的型付けにより、ランタイムエラーを事前に検出することを目的としている。
- 型チェックをパスしてもランタイムエラーは起きうる
- 引数の数が違うなどの明らかにおかしい構文は、JS ではチェックされないけど TS ではチェックされるものがある
- 型注釈は、開発者の意図を明示し、コンパイラが正解と不正解を見分けやすくするために使うもの

## 2. TypeScript のオプションを知る

- TS はオプション設定で劇的に動作が変わる
- JS からの移行プロジェクトを除き、`noImplicitAny`は必ずオン
- `strictNullChecks`も`undefined is not an object`のエラーをなくすために大事
- `strict`はそれら厳しめの設定の盛り合わせであり、オンを推奨
- `strict`よりも厳格な`noUncheckedIndexedAccess`のようなオプションもあるので適宜選択する

## 3. コード生成と型は独立していることを知る

- インターフェース、型、型注釈はトランスパイル時に全て削除される。
  - このためランタイム時に`instanceof SomeType`みないなことはできない。ランタイム時の判定には「タグ付きユニオン」などを使え。
  - また、型がランタイムのパフォーマンスに影響を与えることはない。ビルドタイムには影響を与えるけどね。
- class のように型と値を両方生成するものがある。

```ts
class Foo {}
class Bar {}
// 型として利用
type FooOrBar = Foo | Bar
// 値として利用
if (a instanceof Foo) {
}
```

- 型エラーはあってもトランスパイルはできる。
  - 少々型エラーがあっても動かせた方が開発時には便利だよね。
  - `noEmitOnError`を使うと、型エラーがあるとトランスパイルしないようにできるけど。
- 型アサーション（キャスト、`as Hoge`）しても実際の値は変わらない。
- ランタイムの値は型と相違しうる。だからこそ、unsound な値(any、型アサーション、構造的部分型のミスユース)はなくすのが大事。
- 関数を型レベルでオーバーロード定義することはできるが、実装は一つしか書けない（どゆこと）。

## 4. 構造的部分型と仲良くなる

JS は Duck Typed であり、TS はそのモデリングとして構造的部分型を採用している。
余計なプロパティを持っている可能性があるということ。
TS の型システムは closed/sealed/precise ではなく、open である。

構造的部分型をうまく使うと、テスト時に全てをモックすることなく、必要な部分だけをモックすることができる。
(訳注:あまりそういう例は見たことないけど)

## 5. any を使わない

any はあらゆる厄災のもと。使うな。

- 全ての型チェックが無効化される
- 型安全性が失われる
- DX が悪化する
- リファクタリング時の事故を誘発する
- あなたの型設計を覆い隠す
- 型システムへの自信を喪失させる
