# Effective TypeScript

## 1. TS と JS の関係を知る

- TS は JS のスーパーセット。JS のコードは TS のコードとして使える。
- TS は静的型付けにより、ランタイムエラーを事前に検出することを目的としている。
- 型チェックをパスしてもランタイムエラーは起きうる
- 引数の数が違うなどの明らかにおかしい構文は、JS ではチェックされないけど TS ではチェックされるものがある
- 型注釈は、開発者の意図を明示し、コンパイラが正解と不正解を見分けやすくするために使うもの

## 2. TypeScript のオプションを知る

- TS はオプション設定で劇的に動作が変わる
- JS からの移行プロジェクトを除き、`noImplicitAny`は必ずオン
- `strictNullChecks`も`undefined is not an object`のエラーをなくすために大事
- `strict`はそれら厳しめの設定の盛り合わせであり、オンを推奨
- `strict`よりも厳格な`noUncheckedIndexedAccess`のようなオプションもあるので適宜選択する

## 3. コード生成と型は独立していることを知る

- インターフェース、型、型注釈はトランスパイル時に全て削除される。
  - このためランタイム時に`instanceof SomeType`みないなことはできない。ランタイム時の判定には「タグ付きユニオン」などを使え。
  - また、型がランタイムのパフォーマンスに影響を与えることはない。ビルドタイムには影響を与えるけどね。
- class のように型と値を両方生成するものがある。

```ts
class Foo {}
class Bar {}
// 型として利用
type FooOrBar = Foo | Bar
// 値として利用
if (a instanceof Foo) {
}
```

- 型エラーはあってもトランスパイルはできる。
  - 少々型エラーがあっても動かせた方が開発時には便利だよね。
  - `noEmitOnError`を使うと、型エラーがあるとトランスパイルしないようにできるけど。
- 型アサーション（キャスト、`as Hoge`）しても実際の値は変わらない。
- ランタイムの値は型と相違しうる。だからこそ、unsound な値(any、型アサーション、構造的部分型のミスユース)はなくすのが大事。
- 関数を型レベルでオーバーロード定義することはできるが、実装は一つしか書けない（どゆこと）。

## 4. 構造的部分型と仲良くなる

JS は Duck Typed であり、TS はそのモデリングとして構造的部分型を採用している。
余計なプロパティを持っている可能性があるということ。
TS の型システムは closed/sealed/precise ではなく、open である。

構造的部分型をうまく使うと、テスト時に全てをモックすることなく、必要最低限の部分だけをモックすることができたりする。

## 5. any を使わない

any はあらゆる厄災のもと。使うな。

- 全ての型チェックが無効化される
- 型安全性が失われる
- DX が悪化する
- リファクタリング時の事故を誘発する
- あなたの型設計を覆い隠す
- 型システムへの自信を喪失させる

## 6. エディタ上で型を使い倒す

- TypeScript Language Service はエディタと協調して動作する
- 型がどのように動作しているかを確認できる
- 変数名や名前の変更といった、TypeScript のリファクタリングツールと親しくなろう

## 7. 型は値の集合であると考える

型は、値の集合である。この集合のことを、その型の**ドメイン**と呼ぶ。

集合には有限集合(e.g. boolean, リテラル型)と無限集合(e.g. string, number)がある。

型は厳格な階層構造**ではなく**、ベン図のように交差集合を形成する。
サブセットではないものの共通する部分はある、という状態がありえる。

型のオペレーションは集合（ドメイン、ベン図）に対して行われる。
`A | B` はドメイン A とドメイン B の和集合である。
`A & B` はドメイン A とドメイン B の積集合である。

オブジェクトの場合、余計なプロパティがあったとしても型に属せる。
直感とは異なるかもしれないが、構造的部分型の考え方に基づいている。
そして前述の通り、型のオペレーションは(オブジェクトのプロパティではなく)集合に対して行われるため、
`オブジェクトA & オブジェクトB`は、オブジェクト A とオブジェクト B の両方のプロパティを全て持つオブジェクトを表す。

`extends`、`is assignable`、`is subtype of`は、すべて`is subset of`の言い換えである。
例えば`'a' extends string`は真である。
ある型のドメインが別の型のドメイン内包するとき、代入ができる。

型 B を型 A にアサインできません、ということは、
型 B のドメインが型 A のドメインのサブセットでないということを表す。
または型 B の**値**が型 A のドメインのメンバーでないことを表す。

- 最も小さな集合は never 型
  - 空の集合である
  - あらゆる型のベースとなるため、Bottom Type と呼ばれる
- 次に小さな集合はリテラル型
  - 一つの値だけを含む有限集合である
- number 型は全ての数値を表す無限集合
  - `42`は含まれるが、`"Hello"`は含まれない
- string 型は全ての文字列を表す無限集合
  - `42`は含まれないが、`"Hello"`は含まれる
- 最も大きな集合は unknown 型
  - あらゆる値を含む無限集合である
  - never の対極にあり、Top Type と呼ばれる
  - どんな値でも代入できる

## 8. シンボルが型空間にあるのか値空間にあるのかを知る

TypScript のシンボルは、型空間に存在するものと値空間に存在するものがある。

あらゆる値は型を持つが、これは型空間でのみアクセス可能である。
type や interface は全て消去され、値空間ではアクセス不可能である。
TypeScript Playground にぶっ込んで生成コードを見るとわかりやすい。

class や enum など、型と値を両方生成する要素もある。

`typeof`や`this`は、型空間と値空間で別の意味を持つ。

## 9. 型アサーションより型注釈を使え

型アサーションではなく、型注釈を使え。

関数の返値の型を注釈すると、安全なうえに結果に型が付いて便利。
特にマップするときとかね。

```ts
type Person = { name: string }
const people = ['Alice', 'Bob', 'Charlie'].map((name): Person => ({ name }))
```

型アサーションや non null assertion を使っていいのは、
DOM 操作時など、TS よりも人間がコンテキストを知っているという特殊な状況だけ。
このときは、なぜアサーションの利用が正当化されるのか、コメントをつけておくとよい。

型アサーションをキャストと呼ぶな。他の言語と違って、値は変わらないから。

`as const`は型アサーションじゃなくて、`const context`であり、安全なものである。
値の型を「最も狭い型 + すべて readonly」にするおまじない。

## 10. Object Wrapper Types を使うな

`String`,`Number`,`Boolean`,`Synbol`,`BigInt`は Object Wrapper Types と呼ばれる。

TSではプリミティブな値はメソッドを持たない。
`"Hello".toUpperCase()`は、`"Hello"`が`String`型という
Object Wrapper Types にオンデマンドに変換されることで利用可能になっている。

`new String(hoge)`のようにすると直接扱うこともできるが、使うな。
ただし`String(hoge)`は単にプリミティブ型にキャストするだけなので使ってもよい。
