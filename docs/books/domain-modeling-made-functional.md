# Domain Modeling Made Functional / 関数型ドメインモデリング ドメイン駆動設計と F#でソフトウェアの複雑さに立ち向かおう

## 1. Introducing Domain-Driven Design

DDD の最終ゴールは、全ての関係者が同一のメンタルモデルを使って話をすること。
これにより、早く価値を届け、高い価値を生み、無駄をなくし、保守と拡張を容易にすることができる。

やるべきことは 4 つ。

- ビジネスイベントとワークフローに着目する。データ構造ではなく。
- ドメインをサブドメインに分割する
- サブドメインのなかでモデルをつくる
- 共通言語を作って使う

### ビジネスイベントを通じてドメインを理解する

ビジネスは、ある一時点のデータだけでは表現できないし価値も持たない。

ビジネスは、一連の**ワークフロー**として表現される。
これは、データを別のデータに**変換**していく過程であり、そこにこそ値があるといえる。

この変換を引き起こすきっかけを**ドメインイベント**と呼ぶ。
ドメインイベントは常に「〜が起こった」のような過去形で表現される。

例：

1. **イベント**: 「顧客が注文ボタンを押した」
2. **「商品の注文」ワークフロー**:
   - 注文内容の検証
   - 在庫の確認と引き当て
   - 決済処理
   - 出荷指示の作成
3. **ワークフロー内で発生するデータ変換**:
   - 商品の状態をカート内から確定済みに変更する
   - 在庫数を減少させる
   - 購入履歴に注文を追加する

ドメインイベントの発見にはイベントストーミングという手法が有効である。
イベントストーミングは以下を目的とする。

- 関係者全員で共有できるモデルを作る
- 関係者全員に当事者意識を持たせる
- 仕様の齟齬を見つける
- 部署間の接続がどうなっているか見つけ出す
- 帳票の必要性を明らかにする (=> 過去の出来事を知る必要性がどれくらいあるか)

イベントを洗い出すときには、少ない範囲で満足せず、
可能な限り端まで拡張して見つけ出すことを心がける。

何らかのワークフローを開始するための要求を**コマンド**と呼ぶ。
コマンドは常に命令形で表現される。
人によって引き起こされる場合と、スケジュールや外部システムからの通知で引き起こされる場合がある。
コマンドが成功すると、システムの状態が変更され、一つまたは複数のドメインイベントが記録される。

- `注文を確定しろ`というコマンド -> `注文を確定する`というワークフロー -> `注文が確定された`というイベント
- `発送しろ`というコマンド -> `発送する`というワークフロー -> `発送された`というイベント

### ドメインをサブドメインに分割する

ドメインとは「あるビジネスに密接に関連する知識の範囲」である。

ドメインはサブドメインに分けることができる。
サブドメインとは超ざっくりいうと専門家が存在する分野のことだ。
その専門家が実際に行っている仕事の範囲がサブドメインである。
例えば請求部門の人たちがやっている仕事の範囲が「請求」というサブドメインである。

現実世界のサブドメイン群は、互いにほんの少しだけ重複するベン図として表現できる。

### サブドメインのなかでモデルをつくる

ここまでに出てきたドメイン・サブドメインという用語は、現実世界・問題領域に存在する。
以降は、ソリューションの世界の話になる。

ドメインをソリューションの世界に持ち込むときには、**ドメインモデル**として表現する。
これはドメインをいくぶん簡素化したモデルである。

このとき、サブドメインごとに**Bounded Contexts**を作り、この中にモデルを作っていく。
なぜコンテキストが必要かというと、コンテキストから切り離された情報は混乱を招いたり役に立たなかったりするからである。
なぜ境界を作る必要があるかというと、相互依存をなくして保守性を高めるためである。

現実世界のサブドメインと、ソリューションの世界のBonded Contextは、1 対 1 で結びつくこともあるが、
そうでない場合もあるので注意。
1 対多にしたほうがよいこともあれば、多対 1 にしたほうがよいこともある。

Bounded Context を正しく作るのは難しく、科学ではなくアートの世界とも言えるが、いくつかのコツはある。

- ドメインエキスパートに聞く
- 既存のチームや部署の構成を参考にする (あくまで参考にするだけ)
- 境界をはっきりさせ、適切なサイズにする
- コンテキスト単位でチームが自律できるようにする
- ワークフローがコンテキストをまたがないようにする

Bounded Contextができたら、次に**コンテキストマップをつくる**。
これはコンテキスト間の関係性を示した概略図である。
連携するチームとの関係性を示すドキュメントといえる。

サブドメインは以下の3つに分類される。
まあ現実にはこんなに簡単には分けられないけど、少なくともコアと思われる部分に労力をかけることが大事である。

- Core Domain / ビジネスの価値を生む源泉となるドメイン
- Supportive Domain / 必要だけどコアじゃないドメイン
- Generic Domain / ビジネスと本質的に関係ないドメイン（アウトソースしてもかまわないもの）

### ユビキタス言語を作る

あらゆる場所で使われるべき「ユビキタス言語」をつくる必要がある。
これは経営者も開発者も使う言葉になるべきだし、ソースコードの中でも現れるべき言葉である。
実装の詳細はここには一切含まれない。

ユビキタス言語はコンテキストごとに独立させるのが大事。
そうすることで、要件を簡単にできたり、深刻なデザインの失敗を防いだりすることができる。

## 2. ドメインを理解する

### ドメインエキスパートに聞く

最初の打ち合わせでは一つのワークフロー（例えば「商品を注文する」）を高レベルな視点で把握する。

まずは入出力、つまり処理の開始点と終了点にのみ着目するところから始めるとよい。

- 入力
  - そのワークフローに必要な要素
  - 例えば`紙の注文書`など
  - 入力は複数の場合もある。例えば`紙の注文書`と`商品カタログ`など。
  - トリガーとは別
- 出力
  - 常にイベントになる
  - 例えば`注文が確定した`イベントなど
  - このイベントは他のBounded Contextのトリガーとなる

また、非機能要件も聞き出す。例えば以下のようなもの。

- 利用者は誰か、習熟度はどうか
- 利用頻度はどれくらいか、スパイクはあるか
- 答えを返すまでに許される時間はどれくらいか

### データベースドリブンデザインの誘惑に負けない

ドメインモデルをデザインするときは、データベースのことを忘れることが大事である。
このことを**Persistence ignorance**という。

データベース起点で考えると、データベースの世界に引っ張られて現実世界を歪んで見てしまうことになるからだ。
データベースは現実世界の仕事には存在しないことを忘れるな。

### クラスドリブンデザインの誘惑に負けない

ClassのようなObject-orientedな思考に引っ張られるのもダメである。
どうしてもユビキタスじゃないクラスが出てきてしまって歪むから。

とにかく、要件定義中はコンピューターことや実装の技術的な詳細は一切忘れて、オープンな姿勢でいることが肝要。

### ドメインをドキュメントにする

ドメインの様子がある程度わかってきたら、以下のような自然言語で表現していくとよい。
ここでも、実装の詳細は全く気にしないことが大事。

- Bounded Context: `受注`
- Workflow: `注文の確定`
  - triggerd by:
    - `注文書が届いた`イベント
  - input:
    - 注文書
  - other input:
    - 商品カタログ
  - output events:
    - `注文が確定した`イベント
  - side effects:
    - 確定した注文の情報とともに、発注者に受信通知を送る

データも同様に自然言語に近い形で書くことができる。

- Data: `Order`
  - `CustomerInfo`
  - AND `ShippingAddress`
  - AND `BillingAddress`
  - AND list of `OrderLines`
  - AND `AmountToBill`
- Data: `OrderLine`
  - `Product`
  - AND `Quantity`
  - AND `Price`
- Data `CustomerInfo`
  - unknown yet
- Data: `BillingAddress`
  - unknown yet

### 詳細な設計

続いて、更に詳細な要件をインタビューしていく。例えば以下のようなものだ。

- バリデーションは必要か(住所、メール、商品コード、数量など)
- 価格の計算方法は具体的にどうなっているか
- 外部システムへの依存があるか（住所検索システムなど）
- 処理後に行う特別な作業はあるか

開発者は優先順位を軽視しがち。迷ったら「金を生むか」で考えろ。

### 複雑さをドメインモデルで表現する

インタビューを進めると段々と物事が複雑になってくるがそれでいい。
以下の格言を忘れるな。

> A few weeks of programming can save you hours of planning

以下などを自然言語でドキュメントにまとめていく（詳細 p36-）。

- バリデーションルール
- データの型（段階ごとにどう変わっていくか）
- ワークフロー

## 3. 関数型アーキテクチャ

C4アプローチによるソフトウェアアーキテクチャの定義

- System Context: システム全体
- Containers: デプロイの単位。モノリスなら1つ、マイクロなら複数
- Components: コードを組み立てるときの大まかな単位
- Classes/Modules: メソッド・関数など

### Bounded Contextとソフトウェアコンポーネント

大事なのはBounded Contextがきちんと互いに独立していること。
マイクロサービスである必要はなく、モノリスで構わない。

### Bounded Context間のやりとり

- Bounded Contextは**イベント**を介して相互に通信する
  - イベントはキューイングしてもいいし、モノリスなら直接の関数呼び出しでもかまわない
- 完全に分離された設計により、各コンポーネントが自立して動作できるようにする
- コンテキスト間のデータ転送にはData Transfer Object(DTO)を使う
  - ドメインオブジェクトとは別の、シリアライゼーション可能な専用オブジェクト
  - 送信側でドメインオブジェクト->DTO->JSON/XMLに変換し、受信側では逆をやる
- `Domain Object`は境界の内側でのみ使うオブジェクト。DTOとは反対の性質。
- 入力時には不正な値が入らないようにバリデーション
- 出力時には余計な情報が含まれないようバリデーション

### Bounded Context間の規約

コンテキスト間の規約にはいくつかの典型的なパターンがある。

- Shared Kernel relationship
  - 複数のコンテキストで共通のドメインデザインを共有する
    - e.g. 注文コンテキストと発送コンテキストで`住所`モデルを共有する
  - 修正時には関係する全てのコンテキストの合意が必要
- Customer / Supplier or Consumer-Driven Contract relationship
  - ダウンストリーム側のコンテキスト(=Customer)が欲しいものを宣言する
    - e.g. 決済コンテキストが注文コンテキストに対しカード番号と金額を要求する
  - 要件を満たす限り、アップストリーム側はいつでもコード変更が可能
- Comformist relationship
  - ダウンストリーム側(Conformist)はアップストリーム側から与えられた情報をそのまま使う
    - e.g. 注文コンテキストで「商品カタログ」の情報を使う

アップストリームの情報をダウンストリーム側で使う際に、**Anti-Corruption Layer(ACL)** を設ける場合がある。
ACLの主目的は、外部システムの言語（データ形式、概念、語彙）を自分のドメインの言語に**翻訳**すること。
これによりそれぞれのドメインが独立して進化することが可能になる。
バリデーションや、外界の知識で内部が腐敗することの防止は、実は主目的ではない。

これらの規約やACLを使って**コンテキストマップ**を書くことができる。
マップにより、チーム間の関係性と、それらがどのように協力する（または協力しない）ことが期待されるかもわかる。
ドメインマップを組織に適用する「逆コンウェイの法則」を使うこともある。

### Bounded Contextのなかのワークフロー

実装の世界では、ワークフローは**単一の関数**として表現される。
引数には、コマンドに関連付けられたデータを渡す。
返り値は、イベントオブジェクトの配列になる。これは他のワークフローの起点となる。
ワークフローにはパブリックなものとインターナルなものがある。

関数型では隠れた依存関係をなくすために、Bounded Context内でイベントを発生させることはしない。

## 4. 型を理解する

型とは値の集合のことで、関数の入出力になりうるもの。

関数型プログラミングではValueを使う。VariablesやObjectは使わない。

- Value: immutableな値
- Variables: mutableな値
- ObjectやClass: mutableなデータ構造と、それを改変するための処理をセットにしたもの

型はANDやORによってコンポジションできる。
基礎的な小さな型をスタート地点として、それらをANDやORしながら複雑な型を
作っていく型システムのことを **Algebraic(代数的) Type System** という。

ANDで作る型を`product types`と呼ぶ。
名前の由来は、組み合わせが掛け算で増えていくから。

ORで作る型を`sum types`(または`choice types`/`tagged unions`/`discriminated unions`など)と呼ぶ。
名前の由来は、組み合わせが足し算で増えていくから。

Option/Some/Noneは、値があるかもしれないしないかもしれないものを表現するために使う。

Resultは、関数が成功時も失敗時も値を返すことを表現するために使う。

(訳注：F#の細かい仕様は割愛)

## 5. 型を使ってドメインをモデリングする

### データのモデリング (名詞)

よく使うパターン

- Simple values
  - stringやintといった基礎的な値
  - ただし話をするときは`OrderId`などのユビキタス言語を使う
  - ラッパーを作って使う（TypeScriptならBranded typeか）
- ANDを使った値の組み合わせ
  - 関連データのまとまり
  - 現実世界の紙ドキュメントやその要素などに対応する
    - e.g. 名前、住所、注文群、など
- ORを使った選択肢
  - いくつかの選択肢
  - 注文or見積、個数or重量、など

モデリングの初期段階では内部の詳細が不明な場合が多い。
そういうときは`undefined`などを型として当てておき、後で肉付けする。

### メソッドのモデリング (動詞)

前提として、関数は常にひとつの値を受取り、ひとつの値を出力する。

**複数の値を入力したい**ときは2つのやり方がある。
一つはRecordTypeを使う方法。
もう一つはカリー化のパターンを使う方法（一つずつ適用していく）。
すべての値たちが密結合なのか、それとも一部がDIに適した「依存」なのかを見極め、どちらを使うか選ぶ。

**複数の値を出力**したい場合は、Record Typeを使う。
もし**いずれかの値を出力したい**場合は、Tagged Union Typeを使う。

失敗する可能性がある関数の出力には`Result`、非同期な関数の出力には`Async`などを使って表現する。

### Value Object, Entities

交換できるのものは**Value Object**である。
名前、住所、郵便番号など。
「彼は僕と同じ**名前**だ」のように表現できるものすべて。

これに対し、ユニークなアイデンティティがあり、交換不可能でライフサイクルがあるものを**Entity**という。
注文、請求書、顧客情報など。
識別するためのIDをもつ。IDは現実世界に存在する場合もあれば、ソリューションの世界で人工的に作らなければならない場合もある。

Value ObjectとEntityのどちらに分類するかはコンテキストにより変わってくるので注意する。

Entityでは一部の値を可変にする必要がある。
関数型プログラミングでは、元のオブジェクトをコピーして一部を書き換えることで、改変を行う（つまり、全てはイミュータブル）。

### IDを型のどこに定義するか

Record Typeであれば話は簡単で、単にIDのプロパティを追加すればいい。

ややこしいのはChoice Typeの場合。
やり方としては、それぞれの選択肢の外側に定義する方法と、それぞれの選択肢に埋め込む方法がある。
一般的には後者のほうが、パターンマッチングなどで使いやすいため好まれる。

```typescript
// それぞれの選択肢にIDを埋め込む形の例

interface Dog {
  id: string
  type: 'dog'
  breed: string
  size: 'small' | 'medium' | 'large'
}

interface Bird {
  id: string
  type: 'bird'
  species: string
  canFly: boolean
}

type AnimalWithId = Dog | Bird
```

### Aggregate / 集約

例えば、Order(注文)がOrderLines(注文詳細群)を保持するとする。
ある特定のOrderLineの価格を編集したときは、Orderも別物になるのであわせて編集が必要になる。

このように、他のEntiry群を含むEntityを**Aggregate**という。
また、このときにトップレベルになるEntityを**Aggregate Root**という。

Aggregateは**一貫性が保たれるべき境界**といえる。
たとえば、注文詳細の一部に変更があれば、注文合計金額も更新しないといけないよね。

Aggregateは**永続性を保つ単位**ともいえる。
トランザクションはこの単位で貼ることになる。

Aggregateは**データ送信するときの単位**でもある。
シリアライズするときは必ず全体を対象にする。
一部だけをシリアライズすることはない。

あるAggregateが別のAggregateを参照するときはidを埋め込む。
たとえば、注文と顧客は別の一貫性を保つ必要があり、別の集約である。
よって、注文には顧客IDを埋め込む。顧客エンティティそのものを埋め込まない。

どの単位で集約するかは、ドメインエキスパートとの会話と、ドメインの理解によって導き出されるべき。

### 型とドメインの関係

型をうまく使うと、ドメインを型でそのまま表すことができる。
つまり現実世界のモノ・コト・手続きを、そのままコードとして表現ができる。
これにより、仕様(ドキュメント)とコードを同期させる必要がなくなり、バグも減らすことができる。

## 6. ドメインにおける完全性と一貫性

**完全性(Integrity, Validity)** とは、データがビジネスルールに適合していることを指す。
例えば、注文数が0でないとか、顧客名が空でないとか、注文日が将来日でない、などだ。

**一貫性(Consistency)** とは、ドメインモデルの**複数の部分**が事実に一致していることを指す。
例えば以下のようなものだ。

- 注文の合計金額が、注文詳細群の合計金額と一致しないのは、一貫性がない状態
- 注文が入れば請求書が発行されるはずなのに、注文だけが存在しているのは、一貫性がない状態
- 注文で割引券が使われているのに、割引券が使用済みにマークされていないのは、一貫性がない状態
