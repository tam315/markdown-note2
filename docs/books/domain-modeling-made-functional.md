# Domain Modeling Made Functional / 関数型ドメインモデリング ドメイン駆動設計と F#でソフトウェアの複雑さに立ち向かおう

## 1. Introducing Domain-Driven Design

DDD の最終ゴールは、全ての関係者が同一のメンタルモデルを使って話をすること。
これにより、早く価値を届け、高い価値を生み、無駄をなくし、保守と拡張を容易にすることができる。

やるべきことは 4 つ。

- ビジネスイベントとプロセス(＝ワークフロー)に着目する。データ構造ではなく。
- ドメインをサブドメインに分割する
- サブドメインのなかでモデルをつくる
- 共通言語を作って使う

### ビジネスイベントを通じてドメインを理解する

ビジネスは、ある一時点のデータだけでは表現できないし価値も持たない。

ビジネスは、一連の**プロセス**により**ワークフロー**として表現される。
これは、データを別のデータに**変換**していく過程であり、そこにこそ値があるといえる。

この変換を引き起こすきっかけを**ドメインイベント**と呼ぶ。
ドメインイベントは常に「〜が起こった」のような過去形で表現される。

例：

1. **イベント**: 「顧客が注文ボタンを押した」
2. **プロセス**:
   - 注文内容の検証
   - 在庫の確認と引き当て
   - 決済処理
   - 出荷指示の作成
3. **データ変換**:
   - 商品の状態をカート内から確定済みに変更する
   - 在庫数を減少させる
   - 購入履歴に注文を追加する

ドメインイベントの発見にはイベントストーミングという手法が有効である。
イベントストーミングは以下を目的とする。

- 関係者全員で共有できるモデルを作る
- 関係者全員に当事者意識を持たせる
- 仕様の齟齬を見つける
- 部署間の接続がどうなっているか見つけ出す
- 帳票の必要性を明らかにする (=> 過去の出来事を知る必要性がどれくらいあるか)

イベントを洗い出すときには、少ない範囲で満足せず、
可能な限り端まで拡張して見つけ出すことを心がける。

何らかのプロセスを起こすための要求を**コマンド**と呼ぶ。
コマンドは常に命令形で表現される。
人によって引き起こされる場合と、スケジュールや外部システムからの通知で引き起こされる場合がある。
コマンドが成功すると、システムの状態が変更され、一つまたは複数のドメインイベントが記録される。

- `注文を確定しろ`というコマンド -> `注文を確定する`というプロセス -> `注文が確定された`というイベント
- `発送しろ`というコマンド -> `発送する`というプロセス -> `発送された`というイベント

### ドメインをサブドメインに分割する

ドメインとは「密接に関連する知識の範囲」である。

超ざっくりいうと、ドメインとは専門家が存在する分野のこと。
その専門家が実際に行っている仕事の範囲がドメインである。
例えば請求部門の人たちがやっている仕事の範囲が「請求」というドメインである。

現実世界のドメインは、互いにほんの少しだけ重複するベン図として表現できる。

### Bounded Contexts を使ってソリューションを作る

ここまでに出てきたドメイン・サブドメインは、現実世界・問題領域の話。
以降は、ソリューションの世界の話になる。

ドメインをソリューションの世界に持ち込むときには、**ドメインモデル**として表現される。
これはドメインを簡素化したものである。

このとき**Bounded Contexts**を作る。
なぜコンテキストが必要かというと、コンテキストから切り離された情報は混乱を招いたり役に立たなかったりするからである。
なぜ境界を作る必要があるかというと、相互依存をなくして保守性を高めるためである。

現実世界のサブドメインとソリューションの世界のBonded Contextは、1 対 1 で結びつくこともあるが、
そうでない場合もあるので注意。
1 対多にしたほうがよいこともあれば、多対 1 にしたほうがよいこともある。

Bounded Context を正しく作るのは難しく、科学ではなくアートの世界とも言えるが、いくつかのコツはある。

- ドメインエキスパートに聞く
- 既存のチームや部署の構成を参考にする (あくまで参考にするだけ)
- 境界をはっきりさせ、適切なサイズにする
- コンテキスト単位でチームが自律できるようにする
- プロセスがコンテキストをまたがないようにする

Bounded Contextができたら、次に**コンテキストマップをつくる**。
これはコンテキスト間の関係性を示した概略図である。
連携するチームとの関係性を示すドキュメントといえる。

ドメインには以下の3つがある。
まあ現実にはこんなに簡単には分けられないけど、少なくともコアと思われる部分に労力をかけることが大事である。

- Core Domain / ビジネスの価値を生む源泉となるドメイン
- Supportive Domain / 必要だけどコアじゃないドメイン
- Generic Domain / ビジネスと本質的に関係ないドメイン（アウトソースしてもかまわないもの）

### ユビキタス言語を作る

あらゆる場所で使われるべき「ユビキタス言語」をつくる必要がある。
これは経営者も開発者も使う言葉になるべきだし、ソースコードの中でも現れるべき言葉である。
実装の詳細はここには一切含まれない。

ユビキタス言語はコンテキストごとに独立させるのが大事。
そうすれば、要件を簡単にできるし、深刻なデザインの失敗を防ぐことができる。

## 2. ドメインを理解する

### ドメインエキスパートに聞く

最初の打ち合わせでは一つのプロセス（例えば商品の注文に関する部分）を高レベルな視点で把握する。

まずは入出力、つまり処理の開始点と終了点にのみ着目するところから始めるとよい。

- 入力
  - そのプロセスに必要な要素
  - 例えば`紙の注文書`など
  - 入力は複数の場合もある。例えば`紙の注文書`と`商品カタログ`など。
  - トリガーとは別
- 出力
  - 常にイベントになる
  - 例えば`注文が確定した`イベントなど
  - このイベントは他のBounded Contextのトリガーとなる

また、非機能要件も聞き出す。例えば以下のようなもの。

- 利用者は誰か、習熟度はどうか
- 利用頻度はどれくらいか、スパイクはあるか
- 答えを返すまでに許される時間はどれくらいか

### データベースドリブンデザインの誘惑に負けない

ドメインモデルをデザインするときは、データベースのことを忘れることが大事である。
このことを**Persistence ignorance**という。

データベース起点で考えると、データベースの世界に引っ張られて現実世界を歪んで見てしまうことになるからだ。
データベースは現実世界の仕事には存在しないことを忘れるな。

### クラスドリブンデザインの誘惑に負けない

ClassのようなObject-orientedな思考に引っ張られるのもダメである。
どうしてもユビキタスじゃないクラスが出てきてしまって歪むから。

とにかく、要件定義中はコンピューターことや実装の技術的な詳細は一切忘れて、オープンな姿勢でいることが肝要。

### ドメインをドキュメントにする

ドメインの様子がある程度わかってきたら、以下のような自然言語で表現していくとよい。
ここでも、実装の詳細は全く気にしないことが大事。

- Bounded Context: `受注`
- Workflow: `注文の確定`
  - triggerd by:
    - `注文書が届いた`イベント
  - input:
    - 注文書
  - other input:
    - 商品カタログ
  - output events:
    - `注文が確定した`イベント
  - side effects:
    - 確定した注文の情報とともに、発注者に受信通知を送る

データも同様に自然言語に近い形で書くことができる。

- Data: `Order`
  - `CustomerInfo`
  - AND `ShippingAddress`
  - AND `BillingAddress`
  - AND list of `OrderLines`
  - AND `AmountToBill`
- Data: `OrderLine`
  - `Product`
  - AND `Quantity`
  - AND `Price`
- Data `CustomerInfo`
  - unknown yet
- Data: `BillingAddress`
  - unknown yet

### 詳細な設計

続いて、更に詳細な要件をインタビューしていく。例えば以下のようなものだ。

- バリデーションは必要か(住所、メール、商品コード、数量など)
- 価格の計算方法は具体的にどうなっているか
- 外部システムへの依存があるか（住所検索システムなど）
- 処理後に行う特別な作業はあるか

開発者は優先順位を軽視しがち。迷ったら「金を生むか」で考えろ。

### 複雑さをドメインモデルで表現する

インタビューを進めると段々と物事が複雑になってくるがそれでいい。
以下の格言を忘れるな。

> A few weeks of programming can save you hours of planning

以下などを自然言語でドキュメントにまとめていく（詳細 p36-）。

- バリデーションルール
- データの型（段階ごとにどう変わっていくか）
- ワークフロー

## 3. 関数型アーキテクチャ

C4アプローチによるソフトウェアアーキテクチャの定義

- System Context: システム全体
- Containers: デプロイの単位。モノリスなら1つ、マイクロなら複数
- Components: コードを組み立てるときの大まかな単位
- Classes/Modules: メソッド・関数など

### Bounded Contextとソフトウェアコンポーネント

大事なのはBounded Contextがきちんと互いに独立していること。
マイクロサービスである必要はなく、モノリスで構わない。

### Bounded Context間のやりとり

- Bounded Contextは**イベント**を介して相互に通信する
  - イベントはキューイングしてもいいし、モノリスなら直接の関数呼び出しでもかまわない
- 完全に分離された設計により、各コンポーネントが自立して動作できるようにする
- データ転送にはDTOというドメインオブジェクトとは別の、シリアライゼーション専用オブジェクトを使う
  - 送信側でドメインオブジェクト->DTO->JSON/XMLに変換し、受信側では逆をやる
- 入力時には不正な値が入らないようにバリデーション
- 出力時には余計な情報が含まれないようバリデーション
