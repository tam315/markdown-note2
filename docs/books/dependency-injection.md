# Dependency Injection Principles, Practices, and Patterns

なぜ依存性を注入するのか 〜DIの原理・原則とパターン〜

## 1. 依存注入(Dependency Injection :DI)の基本

DIとは、様々なソフトウェア設計の原則やパターンを集めたもの。
DIの目的は、コードを疎結合にすることで、**保守容易性**を高めること。

DIの文脈では、抽象のことを「サービス」、実装のことを「コンポーネント」ということがある。

### 保守容易性

以下はDIに対してよくある誤解なので、完全に忘れること。

- DIは遅延バインディング(インターフェースを定義して実装は後から考える)にしか使えない
- DIは単体テストにしか使えない
  - それらはDIの用途のごく一部にすぎない
- Abstract Factory パターンと似たものである
  - これはService Locatorといい、命令的に依存を呼び出して利用するもの
  - 依存を必要とするクラスの利用者に対して、提供義務を課すDIとはむしろ対極にあるもの
- DIするにはDIコンテナが必要である
  - DIコンテナはあくまで任意で、Pure DIという方法もある
  - なお、DIコンテナを Service Locator として使うのは完全な間違い

DIとの関係でよく出てくる4パターン

- Decorator パターン
  - 機能追加や横断的関心を、既存コードを変えることなく実装するためのパターン
  - e.g. コンセントと機器の間にUPSを入れる
- Composite パターン
  - 既存の実装クラスとは別の実装クラスを追加してリファクタリングするためのパターン
  - e.g. 電源タップを使って複数の機器を使う
- Adapter パターン
  - 微妙に異なる2つのインターフェースを組み合わせてつけるようにするためのパターン
  - e.g. 海外で形の違うコンセントにアダプタを使う
- Nullオブジェクト
  - サービスが利用不可能でもエラーにならないようにするためのパターン
  - e.g. 使わないコンセントにダミーのキャップをはめておく

**リスコフの置換原則**とは、将来起きうる未知の変更に対応するための考え方。
インターフェースの実装はほかの実装に取り替え可能であるべきという原則。

**開放閉鎖の原則(Open/Closed Principle: OCP)**とは、
既存のコードを変更することなく機能追加を可能にするための考え方。
拡張はできるけど変更はできないようにする原則。

コンセントと家電の例のように、基準を定めて疎結合にすることで、
既存コードに手を入れることもなく、将来の想定外の変化に応えられるようにすることが、DIの本質。

疎結合にする簡単な方法は**インターフェースに対してプログラミングをする**ということ。
インターフェースはnewできないので、どこでオブジェクトを生成するか、という問いが生まれる。
その問いを解決するのが、DIである。
