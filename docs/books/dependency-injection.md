# Dependency Injection Principles, Practices, and Patterns

なぜ依存性を注入するのか 〜DIの原理・原則とパターン〜

## 1. 依存注入(Dependency Injection :DI)の基本

DIとは、様々なソフトウェア設計の原則やパターンを集めたもの。
DIの目的は、コードを疎結合にすることで、**保守容易性**を高めること。

DIの文脈では、抽象のことを**サービス**、実装のことを**コンポーネント**ということがある。

### 目的は保守容易性の向上

以下はDIに対してよくある誤解なので、完全に忘れること。

- DIは遅延バインディング(インターフェースだけを定義して、実装は実行時に選択する)にしか使えない
- DIは単体テストにしか使えない
  - それらはDIの用途のごく一部にすぎない
- Abstract Factory パターンと似たものである
  - これはService Locator パターンといい、クラス自身が外部に対して命令的に依存を取りにいくもので、DIとはむしろ対極にある
- DIするにはDIコンテナが必要である
  - DIコンテナはあくまで任意であり、例えばPure DIという方法もある
  - なお、DIコンテナを Service Locator として使うのは完全な間違い

DIとの関係でよく出てくる4パターン

- Decorator パターン
  - 機能追加や横断的関心を、既存コードを変えることなく実装するためのパターン
  - `type Decorator<T> = (service: T, ...deps: any[]) => T`なイメージ、Tが抽象
  - e.g. コンセントと機器の間にUPSを入れる
- Composite パターン
  - 既存の実装クラスとは別の実装クラスを追加してリファクタリングするためのパターン
  - e.g. 電源タップを使って複数の機器を使う
- Adapter パターン
  - 微妙に異なる2つのインターフェースを組み合わせてつけるようにするためのパターン
  - e.g. 海外で形の違うコンセントにアダプタを使う
- Nullオブジェクト
  - サービスが利用不可能でもエラーにならないようにするためのパターン
  - e.g. 使わないコンセントにダミーのキャップをはめておく

**リスコフの置換原則**とは、将来起きうる未知の変更に対応するための考え方。
実装は、ほかの実装に取り替え可能であるべきという原則。

**開放閉鎖の原則(Open/Closed Principle: OCP)** とは、
既存のコードを変更することなく機能追加を可能にするための考え方。
いつでも拡張はできるけど、既存のコードは変更されないし、する必要もない状態に保つ。

DIの本質とは、コンセントと家電の例のように、**基準を定めて疎結合にする**ことで、
既存コードに手を入れることもなく、将来の想定外の変化に応えられるようにすること。

疎結合にする簡単な方法は**インターフェースに対してプログラミングをする**ということ。
インターフェースはnewできないので、どこでオブジェクトを生成するか、という問いが生まれる。
その問いを解決するのが、DIである。

### DIのメリットって？

DIを実現する方法の一つに、コンストラクタ経由でのDI(Constructor Injection)がある。
必要とする依存を、コンストラクタの引数にインターフェースとして静的に定義する方法。

以下はPure DIの例。

```ts
// 依存するインターフェース（抽象）
interface Logger {
  log(message: string): void
}

// Loggerの具体的な実装
class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(`[LOG] ${message}`)
  }
}

// UserServiceクラスは、コンストラクタでLoggerを受け取る
class UserService {
  // コンストラクタで依存を注入
  constructor(private logger: Logger) {}

  createUser(name: string): void {
    // ユーザー作成処理
    this.logger.log(`ユーザー「${name}」を作成しました`)
  }

  deleteUser(name: string): void {
    // ユーザー削除処理
    this.logger.log(`ユーザー「${name}」を削除しました`)
  }
}

// 使用例
const logger = new ConsoleLogger()
const userService = new UserService(logger) // コンストラクタ経由で依存を注入

userService.createUser('太郎')
userService.deleteUser('次郎')
```

上記のコードは、インターフェースに対してプログラミングをすることで、疎結合を実現している。
でも、本来なら1行で書けるものを大量のコードにする必要がある？
つまり、疎結合(DI)のメリットとは？

- **遅延バインディング** / Late binding
  - JSONなどの設定ファイルによって挙動を制御できるようになる
  - アプリの種類によっては不要
- **拡張容易性** / Extensibility
  - 抽象を使ってコードを書くと、できることが規定&制限され、自然と変更に対してClosedになる
  - 実装にはDecoratorパターンにより、あとから機能を追加できるので、拡張に対してOpenになる
- **並列開発** / Parallel development
  - 抽象が唯一の契約となり、複数チームでの開発が容易になる
- **保守容易性** / Maintainability
  - 単一責任の原則により、影響範囲が明確になる
- **テスト容易性** / Testability
  - ユニットテストも統合テストもやりやすくなる
  - アプリの種類に関わらず必須

### 何を注入する？しない？

**安定依存(stable dependency)** とは、常に存在し、後方互換が保証され、決定的(純粋関数的)な振る舞いをするもの。
また、その依存を置き換えたり、DecorationやInterceptionする必要がないもの。
言語の標準ライブラリや、ドメインに特化した権威的なライブラリなどが当てはまる。

**揮発性依存(volatile dependency)** とは、前述の「疎結合のメリット」を崩すもの。
これらはテストや拡張を難しくする。

- 導入に際して設定や調整が必須の依存(例えばRDBの設置など)
- 非決定的な振る舞いの依存
- 実装がまだない依存
- 一部の環境でしか動作しない依存

**接合部(stem)** とは、抽象と実装の境目のこと。

なんでも抽象化すればいいわけではなく、揮発性依存をDIで扱えるようにするのが大事。
これを後からやるのは至難の業なので、最初からアプリ全体でDIできるようにするのが大事。

### DIの特性

**オブジェクト合成(object composition)** は、
依存となるオブジェクトを外部で組み立て、その依存を必要とするクラスにあたえ、
そのクラスのオブジェクトを生成すること。

クラスが依存を制御することを放棄して、その責務を外部に丸投げすることにより、
依存の一元管理・横断的管理や、**生存期間(lifetime)** の管理がやりやすくなる。

**介入(interception)** は、
実装を差し替えることで処理を追加したり改変したりする能力のこと。
Decoratorパターンのこと。
ログ、アクセス制御、監視といった横断的関心事を、疎結合なコードとして追加するために必要なもの。

なお、DIと制御の反転(Inversion of Control: IOC)は似ているが、DIはIOCの一部にすぎない。
