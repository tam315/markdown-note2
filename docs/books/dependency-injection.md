# Dependency Injection Principles, Practices, and Patterns

なぜ依存性を注入するのか 〜DIの原理・原則とパターン〜

## 超まとめ

本質ではない面倒で不安定な依存(揮発性依存)には、コードから直接依存するのではなく、
コードにはインターフェースだけ定義して、コードの外部から与えよう。

そうすることでコードが疎結合になり、拡張・保守・テストが容易になる。
具体的には、介入したり、置き換えたり、モックしたりできるようになる。

また、依存を用意する場所を合成基点(Composition Root)に移動させることができ、
生存期間の管理など、依存の管理性が向上する。

## 1. 依存注入(Dependency Injection :DI)の基本

DIとは、様々なソフトウェア設計の原則やパターンを集めたもの。
DIの目的は、コードを疎結合にすることで、**保守容易性**を高めること。

DIの文脈では、抽象のことを**サービス**、実装のことを**コンポーネント**ということがある。

### DIの目的

以下はDIに対してよくある誤解なので、完全に忘れること。

- DIは遅延バインディング(インターフェースだけを事前に定義して、実装は実行時に選択する)にしか使えない
- DIは単体テストにしか使えない
  - それらはDIの用途のごく一部にすぎない
- Abstract Factory パターンと似たものである
  - これはService Locator パターンといい、依存を必要とするクラス自身が外部に対して命令的に依存を取りにいくもので、DIとはむしろ対極にある
- DIするにはDIコンテナが必要である
  - DIコンテナはあくまで任意である。例えばPure DIという方法もある。
  - なお、DIコンテナを Service Locator として使うのは完全な間違い

DIとの関係でよく出てくる4パターン

- Decorator パターン
  - 機能追加や横断的関心を、既存コードを変えることなく実装するためのパターン
  - `type Decorator<T> = (service: T, ...deps: any[]) => T`なイメージ、Tが抽象
  - e.g. コンセントと機器の間にUPSを入れる
- Composite パターン
  - 既存の実装クラスとは別の実装クラスを追加してリファクタリングするためのパターン
  - e.g. 電源タップを使って複数の機器を使う
- Adapter パターン
  - 微妙に異なる2つのインターフェースを組み合わせてつけるようにするためのパターン
  - e.g. 海外で形の違うコンセントにアダプタを使う
- Nullオブジェクト
  - サービスが利用不可能でもエラーにならないようにするためのパターン
  - e.g. 使わないコンセントにダミーのキャップをはめておく

**リスコフの置換原則**とは、将来起きうる未知の変更に対応するための考え方。
実装は、ほかの実装に取り替え可能であるべきという原則。

**開放閉鎖の原則(Open/Closed Principle: OCP)** とは、
既存のコードを変更することなく機能追加を可能にするための考え方。
いつでも拡張はできるけど、既存のコードは変更されないし、する必要もない状態に保つ。

DIの本質とは、コンセントと家電の例のように、**基準を定めて疎結合にする**ことで、
既存コードに手を入れることもなく、将来の想定外の変化に応えられるようにすること。

疎結合にする簡単な方法は**インターフェースに対してプログラミングをする**ということ。
そうすることで、インターフェースはnewできないので「どこでオブジェクトを生成するか」という問いが生まれる。
その問いを解決するのが、DIである。

### DIのメリット

DIを実現する方法の一つに、コンストラクタ経由でのDI(Constructor Injection)がある。
必要とする依存を、コンストラクタの引数にインターフェースとして静的に定義する方法。

以下はPure DIの例。

```ts
// 依存するインターフェース（抽象）
interface Logger {
  log(message: string): void
}

// Loggerの具体的な実装
class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(`[LOG] ${message}`)
  }
}

// UserServiceクラスは、コンストラクタでLoggerを受け取る
class UserService {
  // コンストラクタで依存を注入
  constructor(private logger: Logger) {}

  createUser(name: string): void {
    // ユーザー作成処理
    this.logger.log(`ユーザー「${name}」を作成しました`)
  }

  deleteUser(name: string): void {
    // ユーザー削除処理
    this.logger.log(`ユーザー「${name}」を削除しました`)
  }
}

// 使用例
const logger = new ConsoleLogger()
const userService = new UserService(logger) // コンストラクタ経由で依存を注入

userService.createUser('太郎')
userService.deleteUser('次郎')
```

上記のコードは、インターフェースに対してプログラミングをすることで、疎結合を実現している。
でも、本来なら1行で書けるものを、こんなに大量のコードにする正当性がある？
つまり、疎結合(DI)のメリットとは？

- **遅延バインディング** / Late binding
  - JSONなどの設定ファイルによって挙動を制御できるようになる
  - アプリの種類によっては不要ではあるが
- **拡張容易性** / Extensibility
  - 抽象を使ってコードを書くと、できることが規定&制限され、自然と変更に対してClosedになる
  - 実装にはDecoratorパターンにより、あとから機能を追加できるので、拡張に対してOpenになる
- **並列開発** / Parallel development
  - 抽象が唯一の契約となり、複数チームでの開発が容易になる
- **保守容易性** / Maintainability
  - 単一責任の原則により、影響範囲が明確になる
- **テスト容易性** / Testability
  - ユニットテストも統合テストもやりやすくなる
  - アプリの種類に関わらず必須

### DIすべき対象

**安定依存(stable dependency)** とは、常に存在し、後方互換が保証され、決定的(純粋関数的)な振る舞いをするもの。
また、将来にわたって、その依存を置き換えたり、DecorationやInterceptionする必要がないもの。
言語の標準ライブラリや、ドメインに特化した権威的なライブラリなどが当てはまる。

**揮発性依存(volatile dependency)** とは、前述の「疎結合のメリット」を崩すもの。
「テストや拡張を難しくするもの」といえる。

- 導入に際して設定や調整が必須の依存(例えばRDBの設置など)
- 非決定的な振る舞いの依存
- 実装がまだない依存
- 一部の環境でしか動作しない依存

**接合部(stem)** とは、抽象と実装の境目のこと。

なんでも抽象化すればいいわけではなく、揮発性依存をDIで扱えるようにするのが大事。
これを後からやるのは至難の業なので、最初からアプリ全体でDIできるようにするのが大事。

### DIの特性

**オブジェクト合成(object composition)** は、
依存となるオブジェクトを外部で組み立て、その依存を必要とするクラスにあたえ、
そのクラスのオブジェクトを生成すること。

クラスが依存を制御することを放棄して、その責務を外部に丸投げすることにより、
依存の一元管理・横断的管理や、**生存期間(lifetime)** の管理がやりやすくなる。

**介入(interception)** は、
実装を差し替えることで処理を追加したり改変したりする能力のこと。
つまり、Decoratorパターンのこと。
ログ、アクセス制御、監視といった横断的関心事を、疎結合なコードとして追加するために必要である。

なお、DIと制御の反転(Inversion of Control: IOC)は似ているが、**DIはIoCの一例**にすぎない。

## 2. 密結合したアプリケーション

合成容易性を評価するためには「**別のモジュールに置き換えられるか**」を見ていくと良い。
レイヤリングしているにも関わらず、一部のモジュールを置き換えようとしときに、依存元コードを大量に修正しないといけないなら、負け。
通称、ラザニアアーキテクチャ。

当たり前にコードを書いていくと、IDEの自動インポート支援なども相まって、簡単に密結合する。
すべての密結合が悪ではないが、**揮発性依存は疎結合に**しなければならない。

クラスを変更する要因が2つ以上あるなら、**単一責任の原則**に反していることを疑え。
凝集性の高いコードなら、要因は1つしかないはず

遅延バインディングする場合、コンフィグファイルの読み込みはアプリケーションのエントリポイントに近い場所で行い、
それ以外のコードは単に設定を受け取るだけにするべき。

## 3. 依存性を注入したアプリケーション

### どこから作るか

外から見える場所(UI側)からアプリを作っていくと、より早いフィードバックと効率的な開発スピードを得られる。
これはYAGNI原則と関連性を持った、理にかなった進め方だ。

その意味で、まずはUI側で必要なモデル、**View Model** から作ると便利。
たとえば`ProductViewModel`みたいな。
そうすれば、とりあえずUI層の中だけで、そのインターフェースにハマるダミーデータを作り、仮実装ができるから。

とはいえ、これらDTOはDIの観点ではあまり重要ではない。
DTOはただのデータに過ぎず、差し替えたり介入したりすることは無いから。

### 合成基点

**コンストラクタ経由での注入** は、依存を制御をする責務を他のクラスに押し付けているだけ、といえばそれだけだ。
でもそれが重要で、責務を**合成基点(Composition Root)** まで持っていけることにつながる。

合成基点は、まるでコンセントとプラグを自由に組み合わせるように、アプリケーションを柔軟に組み替える場となる。
合成基点はエントリポイントに限りなく近い場所になる。
ここでは、Pure DIしてもいいし、DIコンテナへ委譲してもいい。

**合成基点はUI層と同じ層に置かれることも多い** が、これはある種のトレードオフによる意図的な選択であり、
合成基点がUI層の一部になるわけではないので注意する。
本来なら合成基点とUI層は別の場所であるのが原則。

### IoCの効能と使い所

DIはIoCと深く関わる。
IoCの文脈で大切なのは、主役となるレイヤーがインターフェースを主体的に管理し、
**もっとも使いやすい形で定義する権限** を持っていることである。

何でもインターフェース化すればいいわけではない。
短命なオブジェクトには、置き換え・介入・モックが不要なので、抽象化しても無駄骨に終わる。
例えば、DDDのエンティティ、DTO、View Modelなど。

### DIコンテナ

**DIコンテナ**とは、オブジェクト合成(Object composition)、介入(interception)、
生存管理(lifetime management)に関する作業を自動化するソフトウェアのこと。
合成基点の保守をより行いやすくしてくれるものといえる。
IoCコンテナと呼ばれることもある。

DIコンテナを使うとコードの全体像を把握するのが難しくなるというデメリットもある。
その点、Pure DIであれば、合成基点を見れば何をやっているかはすぐに分かる。

### その他

- **メソッド経由での注入(Method Injection)** とは、関数の引数で依存を受け取る方法のこと。
  エンティティなど、比較的短命なオブジェクトが依存を必要とする場合に使われる。
- **ユーザーに関するコンテキスト** は、ドメイン層でインターフェースとして定義しておき、
  UI層などで事前にアダプトさせてからドメイン層に渡す形にすると良い。
  フレームワークごとの流儀を考えなくて済むし、別のフレームワークに乗り換えるのも簡単になるので。

## 4. DIのデザインパターン

### 合成基点 / Composition Root

合成基点はエントリポイントに限りなく近いところに置く。例えばMainメソッドなど。

その中で、UI層、ドメイン層、データアクセス層のモジュールを好きに組み合わせて、アプリケーションをスタートする。
合成基点に関するコードは独立した関数に切り出しておくと保守性が高まる。

```ts
// 合成基点 - Mainメソッドに限りなく近い場所で使う
function createHomeController() {
  // データアクセス層
  const userRepository = new UserRepository()
  // ドメイン層
  const userService = new UserService(userRepository)
  // UI層
  const homeController = new HomeController(userService)

  return homeController
}
```

大切なのは、合成(オブジェクトグラフの構築)は合成基点でのみ行なうということ。
そうしないと介入が難しくなるから。

また、もしDIコンテナを使う場合、合成基点の外で使うのはNG。
Service Locator というアンチパターンになっちゃうから。

合成基点から、UI層、ドメイン層、データアクセス層などに向いた、多くの依存が発生することは問題ない。
**依存は推移的に発生するものである**ため、たとえ直線的な依存関係で組み立てたとしても、
コードベースが大きくなるにつれて依存関係の数は爆発的に大きくなってしまう。
一方で、合成基点でまとめて依存関係を処理する構成にすれば、結果的に依存関係の数を少なく保てる。

### コンストラクタ経由での注入 / Constructor Injection

ほとんどの場合に最善の選択肢となるのが、Constructor Injection だ。

アプリケーション起動時に、合成基点でまとめて、一度だけ、依存をセットアップする。
依存の存在が常に保証され、使い方も簡単であるという利点がある。

特に、依存のローカルデフォルトを用意できない場合に最適だ。
**ローカルデフォルト** とは、同じレイヤーに所属する、(抽象に対する)実装のこと。

例えば、リポジトリのローカルデフォルトは作れない。
なぜなら、それを作るということはドメイン層から特定のRDBへの依存、
つまりデータアクセス層への依存を作ってしまうからだ。

こういった場合、抽象だけ用意して外部から受け取る、つまりDIが必要になる。
そして、常に依存の存在が保証される Constructor Injection がマッチする。

### メソッド経由での注入

メソッド呼び出し時に依存を外部から渡す方法。
以下のようなケースで利用する。

- **Data-centric Object**が、依存を必要とする場合
  - Data-centric Objectとは:
    - データの保持・表現が主な目的のオブジェクト
    - 実行時に動的に生成される
    - 合成基点の時点ではまだ存在しない
  - e.g. ドメインエンティティが特定のメソッドを実行するときに依存を必要とする場合など
- メソッドを**呼び出すたびに違う種類の依存が必要**となる場合
  - e.g. 価格計算をする際にユーザーコンテキストを依存として必要とする場合など

外部から見分けることのできない密結合、いわゆる
**一時的結合 / Temporal Coupling** を生み出しがちなので、注意して使うこと。
(例えば、あらかじめInitializeメソッドを呼んで依存を与えておかないと、クラスを使ったときにエラーになる、みたいな)

### プロパティ経由での注入 / Property Injection

ローカルデフォルトが用意できており、必要に応じて**任意に上書きしたい場合**に使う。
ローカルデフォルトをクラスプロパティに持っておき、
必要に応じて一度だけセットできるようにすることで実現する。

ただし、依存が任意になる場合というのはめったにない。
特に、ライブラリで使うのはいいが、アプリケーションでは使うな。
合成基点でローカルデフォルトを注入すれば済む話なので。
また、そもそもアプリケーションではローカルデフォルトは避けるべきものである。

## 5. DIのアンチパターン

以下は、すべてコンストラクタによる注入などにリファクタリングすべし。

### Control Fleak

IoCに反して、依存に直接依存したり、依存を直接制御したりすること。
合成基点の外で、揮発性依存の実装を`new`することで発生する。

ファクトリを使うと、この問題が発生しやすい。
(Concrete|Abstruct|Static) Factory のいずれを使ったとしても、
結局は実装への直接依存が発生してしまうのでダメ。

また、依存が未指定の場合に外部デフォルトにフォールバックするコードでも発生しやすい。
これは、実のところ別レイヤーへの依存が常に発生してしまっている。

### Service Locator

合成基点の外で、揮発性依存の取得を**無制限**に行えるようにするアンチパターン。
依存を必要とするクラスに、その依存を**外部から見えない形で**提供できるようにする仕組み。

DIコンテナもサービスロケーターも、機能・役割はほぼ同じだが、
後者には以下の欠陥がある。

- サービスロケーターを使うクラスは、サービスロケーターを**余分な依存**として持つはめになる
- サービスロケーターを利用しているクラスを外から見ても、必要な**依存が何なのか分からない**
- 依存が常に提供されていることが保証されない
- エラーが起こるとすれば、コンパイル時ではなくランタイム時であり、危険

### Ambient Context

揮発性依存へのアクセスを、staticなアクセス・メソッドを介して、
**シングルトン**な形で提供すること。

例えば、現在時刻の取得を行う静的メソッド関数を持つクラスを各所で呼び出して使うなど。

例えばログなどの横断的関心事を扱おうとすると、過剰なConstructor Injectionが発生しがちで、
それを避けたいという同期から、Ambient Contextが生まれることが多い。

依存を隠してしまうため、テストや介入が難しくなる。

### Constrained Construction

遅延バインディングを使うときにのみに発生する。
特定の抽象に対するすべての実装に対して、コンストラクタに特定のシグネチャを持つことを強いること。
詳細略。

## 6. Code Smell

アンチパターンとは、確実に間違ったやり方を指す。
一方で、Code smellは明確に間違いであるとは言いづらいものの、問題を含む可能性を示唆しているものを指す。

### Constructor Over-Injection
