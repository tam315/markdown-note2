# Software Design 202508

## リファクタリング

### リファクタリングは議論になりがち

リファクタリングとは、外部からみた振る舞いを保ちつつ、コードをきれいにすること。

小さくて安全な改修行為を継続的に積み重ねることであり、テストがあることは必須条件である。
先送りにし続けてきた問題が顕在化してから、大規模な改修をまとめて実施したあげく事故る、
みたいなのはリファクタリングとは呼ばないので誤用しないこと。

サイズによって取るべき手法や期間が変わる。

- Small: 単一の関数
- Medium: 複数の関数を組み合わせて何らかの機能を提供するもの(データ永続化、税額計算、API通信、など)
- Large: ユースケースの単位

ソフトウェア開発は複雑さと不確実性に立ち向かうものであり、継続的なリファクタリングは必要不可欠である。
しかし、リファクタリングの成果は目に見えづらく、ビジネスと技術で情報が非対称なこともあって議論になりがち。
お互いにビジネスの成功という共通目的を意識しつつ、共通のメンタルモデルを作って建設的な議論をすることが大事。

### リファクタリングの実施判断力

リファクタリングの実施対象は優先順位づけが必要。

修正予定のあるモジュールや、頻繁に触るモジュールは最優先。
逆に修正予定のない安定したブラックボックスは低優先。せいぜいテスト追加に留める。

小さいリファクタリングを息をするごとくこまめに行うのが大事。
種類、時間、範囲で判断する。

- 関数の抽出やインライン化、不要コードの削除など、軽微な**種類**の作業
- 数分から一時間など、短い**時間**で終わる
- 影響**範囲**が自分だけ

全部直したくなる誘惑に打ち勝ち、適切なタイミングで切り上げる勇気も大事。

### リファクタリングのアンチパターン

- **前提がズレている**
  - あるべき姿や目的がズレているパターン。まずは目線を揃えよう。
  - 理想的なコードとは、変更容易性の高いコードである。
  - 例えばカプセル化され、関心が分離されていることなど。
- **無意味にデザインパターンを適用する**
  - ハンマーを持ったからって釘を探し回るな。
- **自分の知っているパターンだけで実装する**
  - たとえば巨大なサービスパターン(クラス)は、ユースケースパターン(クラス)で改善できることをご存知ですか。
- **コードの間違った共通化**
  - Linterの指摘を鵜呑みにしない
- **名前の改善を躊躇する**
  - なるべくユビキタス言語で名前をつける
  - 文脈を踏まえて名前付けしよう。そうしないと意図を読み取れなかったり、関心がコード内に混在することになりがち。
- **複雑すぎて半端で終わる**
  - イベントストーミングなどを通じて設計からやり直せ
- **振る舞いを変える**
  - バグ修正、パフォーマンス改善、機能変更を同時にやるな
- **歴史的経緯の無視**
  - トレードオフで仕方なくそうなってるかもしれないよ
- **テストがないからリファクタを諦める**
  - AIにテストを書かせろ（本文にはプロンプト紹介あり）
- **リファクタリングを禁じる、後回しにする、しなくていいところにやる、やりすぎる**
  - 常日頃から、優先度の高い箇所に、適切なコストで実施し続けることが大事
- **ビッグリファクタリングをする**
  - 巨大なコードに対峙すると**分析麻痺症候群**に陥ってしまう
  - まずは優先度の高い箇所で小さく始めてみる

### プロダクトマネージャー視点でのリファクタリング

PdMがリファクタリングを考えるときは**価値**の視点が最も大事である。

- **価値**
  - 外部: ユーザー体験向上、プロダクト信頼性向上
  - 内部: コードの理解や変更のしやすさ
- **リスク**
  - 外部: バグや障害によるチャーン誘発、信頼関係の喪失
  - 内部: 開発スピード低下、属人化、モチベーション低下
- **速度**
  - 外部: 価値の素早い提供
  - 内部: 機能追加のしやすさ、開発効率やスループットの向上

上記に加え、**プロダクトライフサイクル**（導入期、成長期、成熟期、衰退期）も意識して判断せよ。

リファクタリングは「やる or やらない」だけでなく、
「いつやる」「どこまでやる」といったグラデーションでもよい。

また、不要な機能の削除といった**プロダクトのリファクタリング**というPdMにしかできない仕事をやるのも大事。

## つまみぐい関数型プログラミング / パターンマッチ

問題は複数のパーツに分割すると簡単になる。
分割したパーツは、再び合成する必要がある。
合成するときに必要な糊となるのが、パターンマッチと高階関数である。

多くの関数型言語では、パターンマッチはswitch, match, caseなどの式で表現される。
プリミティブな値に対してだけではなく、Optionalな値や、オブジェクトや配列に対しても使用できる。

パターンマッチを使うと複雑な条件分岐を完結に記載できる。
また、例外の送出の可能性をなくすことができる。

さらに、Algebraic data types の Sum types(直和型、タグ付きユニオンなどともいう)と組わせると強力である。
複雑なデータ構造と処理を簡潔に表現できるようになるし、
網羅性を検証できるためうっかりミスがなくなる。
