# Software Design 202508

## リファクタリング

### リファクタリングは議論になりがち

リファクタリングとは、**外部からみた振る舞いを保ちつつ**、コードをきれいにすること。

小さくて安全な改修行為を継続的に積み重ねることであり、テストがあることは必須条件である。
先送りにし続けてきた問題が顕在化してから、大規模な改修をまとめて実施したあげく事故る、
みたいなのはリファクタリングとは呼ばないので誤用しないこと。

サイズによって取るべき手法や期間が変わる。

- Small: 単一の関数
- Medium: 複数の関数を組み合わせて何らかの機能を提供するもの(データ永続化、税額計算、API通信、など)
- Large: ユースケースの単位

ソフトウェア開発は複雑さと不確実性に立ち向かうものであり、継続的なリファクタリングは必要不可欠である。
しかし、リファクタリングの成果は目に見えづらく、ビジネスと技術で情報が非対称なこともあって議論になりがち。
お互いにビジネスの成功という共通目的を意識しつつ、**共通のメンタルモデル**を作って建設的な議論をすることが大事。

### リファクタリングの実施判断力

リファクタリングの実施対象は優先順位づけが必要。

- 優先度高: 修正予定のあるモジュールや、頻繁に触るモジュール
- 優先度低: 修正予定のない安定したブラックボックス。せいぜいテスト追加に留める。

小さいリファクタリングを息をするごとくこまめに行うのが大事。
小ささは、種類、時間、範囲で判断する。

- 関数の抽出やインライン化、不要コードの削除など、軽微な**種類**の作業
- 数分から一時間など、短い**時間**で終わる
- 影響**範囲**が自分だけ

全部直したくなる誘惑に打ち勝ち、適切なタイミングで切り上げる勇気も大事。

### リファクタリングのアンチパターン

- **前提がズレている**
  - あるべき姿や目的の認識がチーム内でズレているパターン。まずは目線を揃えよう。
  - 理想的なコードとは、変更容易性の高いコードである。
  - 例えばカプセル化され、関心が分離されていることなど。
- **無意味にデザインパターンを適用する**
  - ハンマーを持ったからって釘を探し回るな
- **自分の知っているパターンだけで実装する**
  - たとえば巨大なサービスパターン(クラス)は、ユースケースパターン(クラス)により分割・改善できることをご存知ですか
- **コードの間違った共通化**
  - Linterの指摘を鵜呑みにしない
- **名前の改善を躊躇する**
  - なるべくユビキタス言語で名前をつける
  - 文脈を踏まえて名前付けしよう。そうしないと意図を読み取れなかったり、関心がコード内に混在することになりがち。
- **複雑すぎて半端で終わる**
  - イベントストーミングなどを通じて設計からやり直せ
- **振る舞いを変える**
  - バグ修正、パフォーマンス改善、機能変更を同時にやるな
- **歴史的経緯の無視**
  - トレードオフで仕方なくそうなってるかもしれないよ
- **テストがないからリファクタを諦める**
  - AIにテストを書かせろ（本文にはプロンプト紹介あり）
- **リファクタリングを禁じる、後回しにする、しなくていいところにやる、やりすぎる**
  - 常日頃から、優先度の高い箇所に、適切なコストで実施し続けることが大事
- **ビッグリファクタリングをする**
  - 巨大なコードに対峙すると**分析麻痺症候群**に陥ってしまう
  - まずは優先度の高い箇所で小さく始めてみる

### プロダクトマネージャー視点でのリファクタリング

PdMがリファクタリングを考えるときは**価値**の視点が最も大事である。

- **価値**
  - 外部: ユーザー体験向上、プロダクト信頼性向上
  - 内部: コードの理解や変更のしやすさ
- **リスク**
  - 外部: バグや障害によるチャーン誘発、信頼関係の喪失
  - 内部: 開発スピード低下、属人化、モチベーション低下
- **速度**
  - 外部: 価値の素早い提供
  - 内部: 機能追加のしやすさ、開発効率やスループットの向上

上記に加え、**プロダクトライフサイクル**（導入期、成長期、成熟期、衰退期）も意識して判断せよ。

リファクタリングは「やる or やらない」だけでなく、
「いつやる」「どこまでやる」といったグラデーションでもよい。

また、不要な機能の削除といった**プロダクトのリファクタリング**というPdMにしかできない仕事をやるのも大事。

## ファイルシステム入門

### ファイルとディレクトリ

UNIXではすべてをファイルとして扱うことで、統一的な操作を可能にしている。

実際には実体を持たない「ファイルのようなもの」もある(`/dev/null`や`/proc/cpuinfo`など)。

NTFSやAPFSといった**ファイルシステム**は多くの種類が存在する。これは過去の経緯や最適化の結果である。

**inode**はファイルのメタデータを格納する構造体。ファイルごとにinode番号が振られる。
ディレクトリは、ファイル名とinode番号のペアを格納している**ファイル**である。
ファイル自体を格納しているわけではない点に注意。

だからこそ、同じinode番号を持つファイルを複数もつ**ハードリンク**が可能になる。
なお、循環参照を防ぐため、ディレクトリに対するハードリンクは作れない。

ファイルの種類はいくつかある。`ls -l`したときの頭が種類を表す。

- ディレクトリ `d`
- キャラクタデバイス `c` (e.g. `dev/null`)
- ブロックデバイス `b` (e.g. `dev/sda`)
- ソケット `s`
- シンボリックリンク `l`
- FIFO `p`
- 通常ファイル `-`

シンボリックリンクは**リンクファイル**という特殊なファイル。
inode番号を直接参照しないので、別のファイルシステムへの参照を持つことができる。

プロセスがファイルを使っていると、ディレクトリからは消えたけどinodeやファイルの実体は残っているという状態があり得る。
プロセスが終了した時点で初めて削除される。

### ファイルの読み書き

まずファイルを開いて **ファイルディスクリプタ(fd)** を取得する。
これはファイルを識別するための整数である。
あるプロセスが開いているファイルは`/proc/{PID}/fd/`ディレクトリで確認できる。
用事が終わったら閉じる必要がある。

読み書き時には**ページキャッシュ**という仕組みが動作する。
メモリ上とストレージ上のデータが異なる領域を**Dirty Page**と呼ぶ。
それが増えたり一定時間が経過したりすると、Dirty Pageが書き込まれる(flush)。
sync, syncfs, fsyncなどのシステムコールで明示的に書き込むことも可能。

**遅延アロケーション**は、ストレージの位置決めを遅延させることで効率化を図る仕組み。
現代のファイルシステムでは標準的。

**マウント**とは、あるディレクトリに別のファイルシステムを接続すること。
どこにでもマウントできるが`/mnt`や`/media`配下にマウントするのが慣習。
`/etc/fstab`に必要な情報を書いておくと起動時に**自動マウント**される。

通常のマウントがデバイスやファイルシステムをマウントするのに対し、
**bind mount**という、ファイルシステム内の（一般的には）ディレクトリを
別のディレクトリからアクセス可能にする仕組みがある。
Dockerのボリュームマウントはこの仕組みで実現されている。
同じinode番号を降ることで実現される。

### いろいろなファイルシステム

- FAT32
  - USBメモリでよく使われるファイルシステム
  - 最小構成、シンプル、汎用的
  - 512Bの**セクタ**が基本単位
  - 4KB(8セクタ)や8KB(16セクタ)という**クラスタ**単位で領域管理する
  - FATテーブルと呼ばれる場所でクラスタチェーン(保存場所の連鎖)を管理する
  - ファイルもディレクトリも実体はクラスタ上にデータとして保存される
  - ディレクトリのデータは**ディレクトリエントリ**と呼ばれる
  - ディレクトリエントリにはファイルのメタデータが全て保存されている（ファイルの実体にはメタデータは一切保存されない）
- ext4
  - Linuxで標準的なファイルシステム
  - 4KB（通常）の**ブロック**が基本単位
  - extentという連続ブロック範囲の概念でファイル配置を効率的に管理
  - 変更操作を事前に「ジャーナル」と呼ばれる専用領域に記録しておく仕組みにより、事故からの回復が可能
  - ディレクトリはファイルと本質的に同じ扱いである
  - ファイル(含むディレクトリ)は **inode**というメタデータを格納する構造体で管理される
    - 権限、タイムスタンプ、データブロックへのポインタなどを含む
    - 名前(ファイル名・ディレクトリ名)は含まない
  - 名前は**ディレクトリエントリ**で管理される
    - ディレクトリのデータブロックに羅列される
    - ディレクトリ配下のファイル群のinode番号とファイル名がペアで保存される
- OverlayFS
  - 複数のディレクトリを重ね合わせて統合ビューを提供する
    - 下位層（Lower）: 読み取り専用のベースイメージ
    - 上位層（Upper）: 書き込み可能な差分レイヤ
    - 作業層（Work）: 一時的な作業領域
  - ファイル変更時はCopy-on-Write（CoW）により下位層から上位層にコピーして変更
  - コンテナでよく利用される

## つまみぐい関数型プログラミング / パターンマッチ

問題は複数のパーツに分割すると簡単になる。
分割したパーツは、再び合成する必要がある。
合成するときに必要な糊となるのが、パターンマッチと高階関数である。

多くの関数型言語では、パターンマッチはswitch, match, caseなどの式で表現される。
プリミティブな値に対してだけではなく、Optionalな値や、オブジェクトや配列に対しても使用できる。

パターンマッチを使うと複雑な条件分岐を完結に記載できる。
また、例外の送出の可能性をなくすことができる。

さらに、Algebraic data types の Sum types(直和型、タグ付きユニオンなどともいう)と組わせると強力である。
複雑なデータ構造と処理を簡潔に表現できるようになるし、
網羅性を検証できるためうっかりミスがなくなる。
