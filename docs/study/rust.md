# Rust

## ã‚³ãƒ¡ãƒ³ãƒˆ

- `//`ã¨`/* */`ãŒä½¿ãˆã‚‹ã€‚
- `///`ã‚’ä½¿ã†ã¨[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ¡ãƒ³ãƒˆ](https://doc.rust-lang.org/rust-by-example/meta/doc.html)ã«ãªã‚‹
  - ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã§æ›¸ã„ãŸã‚³ãƒ¡ãƒ³ãƒˆãŒ HTML ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ãªã‚‹

## å¤‰æ•°ã¨å¯å¤‰æ€§

- å¤‰æ•°
  - ä¸å¤‰ `let x=5`
    - ã¡ãªã¿ã« rust ã§ã¯ã€Œå€¤ 5 ã‚’ x ã«æ‹˜æŸã™ã‚‹ã€ã¨ã„ã†è¡¨ç¾ã‚’ã™ã‚‹
  - å¯å¤‰ `let mut x=5`
  - å‘½åè¦å‰‡ã¯å°æ–‡å­—ã®ã‚¹ãƒãƒ¼ã‚¯ã‚±ãƒ¼ã‚¹
- å®šæ•°
  - `const MAX_POINTS: u32 = 100_000`
  - å‘½åè¦å‰‡ã¯å¤§æ–‡å­—ã®ã‚¹ãƒãƒ¼ã‚¯ã‚±ãƒ¼ã‚¹
  - å‹æ³¨é‡ˆã¯å¿…é ˆ
  - ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å€¤ãŒå®šã¾ã‚‹å¼ï¼ˆå®šæ•°å¼ï¼‰ã®ã¿ã‚’ã‚»ãƒƒãƒˆã§ãã‚‹
    - ä¸€æ–¹ã§ immutable ãª**å¤‰æ•°**ã¯ã‚ã‚‰ã‚†ã‚‹å¼(e.g. é–¢æ•°ã®æˆ»ã‚Šå€¤ãªã©)ã‚’ã‚»ãƒƒãƒˆã§ãã‚‹
- ã‚·ãƒ£ãƒ‰ãƒ¼ã‚¤ãƒ³ã‚°
  - å‰ã«å®šç¾©ã—ãŸå¤‰æ•°ã¨åŒã˜åå‰ã®å¤‰æ•°ã‚’æ–°ã—ãå®£è¨€ã—ã¦ä¸Šæ›¸ãã™ã‚‹ã“ã¨
  - `mut`ã¯ã‚ãã¾ã§åŒã˜å‹ã ãŒã€ã‚·ãƒ£ãƒ‰ãƒ¼ã‚¤ãƒ³ã‚°ã¯å‹ã‚’å¤‰æ›´ã§ãã‚‹
  - ã†ã¾ãä½¿ã†ã¨ã‚³ãƒ¼ãƒ‰ã‚’å¯èª­æ€§ã‚’å‘ä¸Šã•ã›ãŸã‚Šã€å‡¡ãƒŸã‚¹ã®å¯èƒ½æ€§ã‚’æ¸›ã‚‰ã—ãŸã‚Šã§ãã‚‹

## ãƒ‡ãƒ¼ã‚¿å‹

å¤§ããã‚ã‘ã¦ã‚¹ã‚«ãƒ©ãƒ¼å‹ã¨è¤‡åˆå‹ãŒã‚ã‚‹ã€‚

### ã‚¹ã‚«ãƒ©ãƒ¼å‹

ã‚¹ã‚«ãƒ©ãƒ¼å‹ã«ã¯åŸºæº–å‹ãŒã‚ã‚‹ã€‚åŸºæº–å‹ã¨ã„ã†ã®ã¯ã€å‹æ³¨é‡ˆã®ãªã„å¤‰æ•°å®£è¨€ãªã©ã§ã€å„ªå…ˆã—ã¦é¸æŠã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿å‹ã®ã“ã¨ã€‚

- æ•´æ•°
  - i8, u8, i16, u16, i32, u32, i64, u64, isize, usize
  - åŸºæº–å‹ã¯`i32`
- æµ®å‹•å°æ•°ç‚¹æ•°
  - f32(å˜ç²¾åº¦æµ®å‹•å°æ•°ç‚¹æ•°), f64(å€ç²¾åº¦æµ®å‹•å°æ•°ç‚¹æ•°)
  - åŸºæº–å‹ã¯`f64`
- è«–ç†å€¤å‹
- æ–‡å­—å‹
  - char å‹
  - ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚ªãƒ¼ãƒˆã§è¡¨ã™
  - ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰ã«ãŠã‘ã‚‹ 1 ã¤ã®ã‚¹ã‚«ãƒ©ãƒ¼å€¤
    - ã‚ˆã£ã¦ä¸–é–“ä¸€èˆ¬çš„ãªã€Œæ–‡å­—ã€ã¨ã¯é›¢ã‚ŒãŸæ€§è³ªã®ã‚‚ã®ã‚‚å«ã¾ã‚Œã‚‹(e.g. ã‚¼ãƒ­å¹…ã‚¹ãƒšãƒ¼ã‚¹)

### Tuple å‹ï¼ˆè¤‡åˆå‹ï¼‰

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
// or
let tup = (500, 6.4, 1);

// åˆ†é…ã¨å‘¼ã°ã‚Œã‚‹ä»£å…¥æ–¹æ³•
let (x, y, z) = tup;

// 0ç•ªç›®ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹
let five_hundred = x.0;
```

### Array å‹(è¤‡åˆå‹)

```rust
let a = [1, 2, 3, 4, 5];

// æ·»å­—ã‚’ä½¿ã£ãŸã‚¢ã‚¯ã‚»ã‚¹
let first = a[0];
let second = a[1];

// å‹ã‚’æŒ‡å®šã™ã‚‹æ–¹æ³•
let a: [i32; 5] = [1, 2, 3, 4, 5];
let b: &[i32] = &a;
```

- ä¸€åº¦å®£è¨€ã—ãŸ Array ã®è¦ç´ æ•°ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã§ããªã„
- å¯å¤‰é•·ãŒå¿…è¦ãªå ´åˆã¯ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆe.g. Vector å‹ï¼‰ã‚’ä½¿ã†å¿…è¦ãŒã‚ã‚‹
- Array ã®çµ‚ç«¯ã‚’è¶…ãˆãŸã‚¢ã‚¯ã‚»ã‚¹ã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚‹

### æ¨è«–

è¤‡æ•°ã®å‹ãŒæ¨è«–ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹å ´åˆã€å‹æ³¨é‡ˆãŒå¿…é ˆã€‚

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

## ãƒªãƒ†ãƒ©ãƒ«

ãƒªãƒ†ãƒ©ãƒ«ã¨ã¯ã€Œè¦‹ãŸã¾ã¾ã®ã‚‚ã®ã€ã€ã¤ã¾ã‚Š**æ•°å€¤ã‚„æ–‡å­—ãªã©ã®å€¤ãã®ã‚‚ã®**ã®ã“ã¨ã€‚

- æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«
  - `123`
  - `12345u32` æœ«å°¾ã«å‹ã‚’ã¤ã‘ã‚‹ã“ã¨ã‚‚ã§ãã‚‹
  - `12_345_u32` ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã§åŒºåˆ‡ã‚‹ã“ã¨ã‚‚ã§ãã‚‹
  - `0xffff`
  - `1.23` ãªã©
- æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«
  - `"Hello, world!"`
  - å‹ã¯`&str`
    - å®Ÿä½“ã¯ãƒã‚¤ãƒˆåˆ—ã® Slice `&[u8]`
    - æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã ã‘ã¯é™çš„é ˜åŸŸã«æ ¼ç´ã•ã‚Œã€ãã“ã¸ã®å‚ç…§ãŒå¤‰æ•°ã«ã‚»ãƒƒãƒˆã•ã‚Œã‚‹
  - æ–‡å­—åˆ—å‹**ã§ã¯ãªã„**
    - ãªãŠ Rust ã«ã¯æ–‡å­—åˆ—å‹ã¯**ãªã„**ã‹ã‚ã‚Šã« String ã¨ã„ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§è¡¨ç¾ã•ã‚Œã‚‹
  - æ–‡å­—åˆ—ã«é–¢ã™ã‚‹ã”ã¡ã‚ƒã”ã¡ã‚ƒã®åˆ†ã‹ã‚Šã‚„ã™ã„èª¬æ˜ -> https://qiita.com/k-yaina60/items/4c8e3562fe6d22f845a9
- char å‹ãƒªãƒ†ãƒ©ãƒ«
  - `'a'`, `'ã‚'` ãªã©
- bool å‹ãƒªãƒ†ãƒ©ãƒ«
  - `true` åˆã¯ `false`

## ãƒ¡ãƒ¢ãƒªã®ç¨®é¡ã¨å¤‰æ•°ã®æ ¼ç´å ´æ‰€

- å‚è€ƒ
  - https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/the-stack-and-the-heap.html
  - https://qiita.com/k-yaina60/items/26bf1d2e372042eff022

### Static memory / é™çš„ãƒ¡ãƒ¢ãƒª

- ç”Ÿæˆã•ã‚ŒãŸå®Ÿè¡Œãƒã‚¤ãƒŠãƒªã«å«ã¾ã‚Œã‚‹
- ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®é–‹å§‹ã‹ã‚‰çµ‚äº†ã¾ã§ãšã£ã¨å­˜åœ¨ã—ç¶šã‘ã‚‹
- é™çš„é ˜åŸŸ/ static memory / rodata (read-only data) segment ãªã©ã¨å‘¼ã°ã‚Œã‚‹
- ã‚¹ã‚¿ãƒƒã‚¯ãƒ¡ãƒ¢ãƒªã§ã‚‚ãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªã§ã‚‚ãªã„ç‰¹æ®Šãªé ˜åŸŸ
- æ ¼ç´å¯¾è±¡
  - æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«
  - `static`ã‚’ã¤ã‘ã¦å®£è¨€ã—ãŸå€¤
    - e.g. `static FOO: usize = 42;`

### Stack memory / ã‚¹ã‚¿ãƒƒã‚¯ãƒ¡ãƒ¢ãƒª

- ğŸŸ¢ é€Ÿã„
- ğŸ”´ å‘¼ã³å‡ºã—å…ƒã¯ãƒ­ãƒ¼ã‚«ãƒ«ï¼ˆå˜ä¸€ã®é–¢æ•°å†…ï¼‰ã«é™ã‚‰ã‚Œã‚‹
- ğŸ”´ ã‚µã‚¤ã‚ºã«ä¸Šé™ãŒã‚ã‚‹
- Stack Frame ã¨ã‚‚å‘¼ã°ã‚Œã‚‹
- rust ã®å€¤ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã“ã“ã«ä¿æŒã•ã‚Œã‚‹
- æ ¼ç´å¯¾è±¡
  - æ•´æ•°å‹ã€æµ®å‹•å°æ•°ç‚¹å‹ã€è«–ç†å€¤å‹ã€å‚ç…§(å«ã‚€ Slice)
  - ä¸Šè¨˜ã‹ã‚‰æˆã‚‹ Tuple ã‚„ Array ã‚„ Struct ã®è¦‹å‡ºã—ãŠã‚ˆã³æœ¬ä½“ï¼Ÿ

### Heap memory / ãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒª

- ğŸ”´ é…ã„
- ğŸŸ¢ ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«åˆ©ç”¨ã§ãã‚‹
- ğŸŸ¢ ã‚µã‚¤ã‚ºã«ä¸Šé™ãŒãªã„
- æ ¼ç´å¯¾è±¡
  - Stringã€Vectorã€Box ã®æœ¬ä½“ï¼ˆè¦‹å‡ºã—ã¯ Stack ã«æ ¼ç´ã•ã‚Œã‚‹ï¼‰
  - ä¸Šè¨˜ã‚’å«ã‚€ Tuple ã‚„ Array ã‚„ Struct ã®æœ¬ä½“ï¼ˆè¦‹å‡ºã—ã¯ Stack ã«æ ¼ç´ã•ã‚Œã‚‹ï¼‰ï¼Ÿ

### Arrayãƒ»Vectorãƒ»Slice ã¨ãƒ¡ãƒ¢ãƒªã®é–¢ä¿‚

- Array
  - å‹ã¯`[è¦ç´ ã®å‹; è¦ç´ æ•°]`
- Vector
  - å‹ã¯`Vec<è¦ç´ ã®å‹>`
- Slice
  - å‹ã¯`&[è¦ç´ ã®å‹]`ã€å¯å¤‰ãªã‚‰`&mut [è¦ç´ ã®å‹]`

## æ–‡ã¨å¼

- æ–‡ / Statement
  - å€¤ã‚’è¿”ã•ãªã„
  - `;`ã§çµ‚ã‚ã‚‹
- å¼ / Expression
  - å€¤ã‚’è¿”ã™
  - `;`ã¯ä¸è¦
  - ä¾‹
    - ã‚¹ã‚«ãƒ©å€¤
    - ãƒã‚¯ãƒ­å‘¼ã³å‡ºã—
    - æœ«å°¾ã«`;`ã®ãªã„é–¢æ•°å‘¼ã³å‡ºã—
    - æœ«å°¾ã«`;`ã®ãªã„ã‚¹ã‚³ãƒ¼ãƒ—

## é–¢æ•°

- å‘½åè¦å‰‡ã¯å°æ–‡å­—ã®ã‚¹ãƒãƒ¼ã‚¯ã‚±ãƒ¼ã‚¹
- `expected hogehoge, found "()"` ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ã¯ã€return ã—ã‚ã™ã‚ŒãŸã¨ãã«ã‚ˆãå‡ºã‚‹
  - if å¼ã‚„ while å¼è‡ªä½“ãŒç©ºã® Tuple`()`ã‚’è¿”ã™ã“ã¨ã«èµ·å› ã—ã¦ã„ã‚‹

```rust
// ã‚·ãƒ³ãƒ—ãƒ«ãªé–¢æ•°
fn say_hello() {
    println!("hello!")
}

// å¼•æ•°ã‚ã‚Š
fn say_hello(num: i32) {
    println!("number is {}", num)
}

// å¼•ãæ•°ã‚ã‚Š(å€¤ã‚’æ›¸ãæ›ãˆã¦ã‹ã‚‰é–¢æ•°å†…ã§åˆ©ç”¨ã—ãŸã„å ´åˆ)
// - å¤‰æ›´ã—ãŸå€¤ã¯ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§ã®ã¿æœ‰åŠ¹ã§ã€å‘¼ã³å‡ºã—å…ƒã«ã¯åæ˜ ã•ã‚Œãªã„
// - mutã®ä½ç½®ã«æ³¨æ„
fn mutate_number(mut y: i32) {
    y - 1;
    println!("{}", y)
}

// å¼•ãæ•°ã‚ã‚Š(å‘¼ã³å‡ºã—å…ƒã®å€¤ã‚’æ›¸ãæ›ãˆãŸã„å ´åˆ)
// - mutã®ä½ç½®ã«æ³¨æ„
// - `&`ã«æ³¨æ„
fn mutate_number(y: &mut i32) {
    *y = 64;
}

// æˆ»ã‚Šå€¤ã‚ã‚Šï¼ˆreturnã‚’ä½¿ã†å ´åˆï¼‰
fn say_hello() -> i32 {
    return 32;
}

// æˆ»ã‚Šå€¤ã‚ã‚Šï¼ˆå¼ã‚’ä½¿ã†å ´åˆï¼‰
fn say_hello2() -> i32 {
    32
}
```

## ãƒ•ãƒ­ãƒ¼åˆ¶å¾¡

### if

```rust
if age >= 35 {
    println!("å¤§äºº");
} else if age >= 18 {
    println!("è‹¥è€…");
} else {
    println!("å­ä¾›");
}
```

å¼ãªã®ã§ä»£å…¥ã‚‚ã§ãã‚‹ã€‚ãã®éš›ã¯ã‚»ãƒŸã‚³ãƒ­ãƒ³ã‚’çœç•¥ã™ã‚‹ã“ã¨ã€‚

```rust
let num = if true {
    5
} else {
    6
};
```

### match

ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ãŒè¡Œãˆã‚‹ã€‚è©³ç´°å¾Œè¿°ã€‚

```rust
let letter = 'A';
let str = match letter {
    'A' => "Aã§ã™",
    'B' | 'C' | 'D' => "Bã€Cã€Dã®ã„ãšã‚Œã‹ã§ã™",
    '0'..='9' | 'A'..='F' => "16é€²æ•°ã§ã¤ã‹ãˆã¾ã™",
    _ => "ã„ãšã‚Œã§ã‚‚ãªã„æ–‡å­—ã§ã™",
};
println!("{}ã¯{}ã§ã™ã€‚", letter, str);
```

### for

- åˆæœŸåŒ–ã€æ¡ä»¶ã€ç¹°ã‚Šè¿”ã—å‰å‡¦ç†ã®ã‚ˆã†ãªæ§‹æ–‡ã¯ãªã„
- `break` ãŒä½¿ãˆã‚‹

```rust
let numbers = [10, 20, 30, 40, 50];
for thisNumber in numbers.iter() {
    println!("the value is: {}", thisNumber);
}
```

### loop

```rust
loop {
    // do something
}
```

- `break`ãŒä½¿ãˆã‚‹
  - å”¯ä¸€ã€`break` æ™‚ã«å€¤ã‚’è¿”ã™ã“ã¨ã‚‚ã§ãã‚‹ã€‚è¿”ã•ãªãã¦ã‚‚ã„ã„ã€‚

```rust
let number = loop {
    break 100
}
```

### while

- `break` ãŒä½¿ãˆã‚‹

```rust
while number != 0 {
    // do something
}
```

### range

```rust
for number in (1..4) {
    // do something
}
```

## æ‰€æœ‰æ¨©

- Rust ã®å€¤ã¯å¿…ãš 1 ã¤ã®ã€Œæ‰€æœ‰è€…ã€ã¨å‘¼ã°ã‚Œã‚‹å¤‰æ•°ã¨å¯¾å¿œã—ã¦ã„ã‚‹
- æ‰€æœ‰è€…ãŒã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å¤–ã‚ŒãŸã‚‰ã€å€¤ã¯ç ´æ£„ã•ã‚Œã‚‹ã€‚
- ãªãœæ‰€æœ‰æ¨©ãŒå¿…è¦ãªã®ã‹ï¼Ÿ
  - ãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªã‚’åŠ¹ç‡çš„ã«ç®¡ç†ã™ã‚‹ãŸã‚
  - ãƒ¡ãƒ¢ãƒªã®äºŒé‡é–‹æ”¾ã‚’é˜²ããŸã‚
  - Garbage collection ã‚’ä¸è¦ã«ã™ã‚‹ãŸã‚

### ã‚³ãƒ”ãƒ¼ã‹ãƒ ãƒ¼ãƒ–ã‹ã€ãã‚ŒãŒå•é¡Œã 

Stack memory ã¾ãŸã¯ Static memory ä¸Šã«å®Ÿä½“ãŒã‚ã‚‹å‹ï¼ˆCopy ãƒˆãƒ¬ã‚¤ãƒˆã‚’ã‚‚ã¤å‹ï¼‰ã¯ã€ä»£å…¥æ™‚ã‚„é–¢æ•°å‘¼ã³å‡ºã—æ™‚ã«å€¤ãŒãƒ¡ãƒ¢ãƒªä¸Šã§ã‚³ãƒ”ãƒ¼ã•ã‚ŒãŸã†ãˆã€æ‰€æœ‰æ¨©ã‚‚ãã‚Œãã‚Œã«è¨­å®šã•ã‚Œã‚‹ãŸã‚ã€ã©ã¡ã‚‰ã‚‚å¼•ãç¶šãåˆ©ç”¨ãŒã§ãã‚‹ã€‚

(ãŸã¨ãˆä¸€éƒ¨ã§ã‚‚) Heap Memory ä¸Šã«å®Ÿä½“ãŒã‚ã‚‹å‹ï¼ˆCopy ãƒˆãƒ¬ã‚¤ãƒˆã‚’ã‚‚ãŸãªã„å‹ï¼‰ã¯ã€ä»£å…¥æ™‚ã‚„é–¢æ•°å‘¼ã³å‡ºã—æ™‚ã«ãƒ¡ãƒ¢ãƒªä¸Šã®å€¤ã¯ã‚³ãƒ”ãƒ¼ã•ã‚Œãšã«ã€æ‰€æœ‰æ¨©ã®ã¿ãŒæ–°ãŸãªå¤‰æ•°ãƒ»å¼•æ•°ã«ç§»å‹•ã—ãŸã†ãˆã€å¤ã„æ‰€æœ‰è€…ã¯ç„¡åŠ¹ã«ãªã‚Šä½¿ãˆãªããªã‚‹ã€‚

### å‚ç…§ã¨å€Ÿç”¨

é–¢æ•°ã‚’å‘¼ã¶éš›ã®å¼•æ•°ã¨ã—ã¦ã€å®Ÿä½“ã®ä»£ã‚ã‚Šã«å‚ç…§ã‚’ä¸ãˆã‚‹ã“ã¨ã§æ‰€æœ‰æ¨©ã®ç§»è»¢ã‚’é˜²ãã“ã¨ã‚’**å€Ÿç”¨**ã¨å‘¼ã¶

```rust
fn main() {
    let greeting = "hello".to_string();
    let length = count_string(&greeting);
    println!("{}ã®é•·ã•ã¯{}ã§ã™", greeting, length);
}

fn count_string(string_to_count: &str) -> usize {
  // æ–°ãŸã«å®šç¾©ã•ã‚ŒãŸstring_to_countã«ã€greetingã®å‚ç…§ãŒä»£å…¥ã•ã‚Œã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸

  return string_to_count.len();

  // `string_to_count`ã¯ã“ã“ã§ç ´æ£„ã•ã‚Œã‚‹ãŒã€ã—ã‚‡ã›ã‚“å‚ç…§ã«ã™ããªã„ã®ã§
  // ã‚‚ã¨ã®å€¤ã¯ç ´æ£„ã•ã‚Œãªã„ã€‚
}
```

- ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§ã¯ã€ä¸å¤‰å‚ç…§ã¯ã„ãã¤ã§ã‚‚ä½¿ãˆã‚‹ãŒã€å¯å¤‰å‚ç…§ã¯ä¸€ã¤ã—ã‹ä½¿ãˆãªã„
- å‚ç…§ã¯å¸¸ã«æœ‰åŠ¹ãªå¤‰æ•°ã«å¯¾å¿œã—ã¦ã„ãªã‘ã‚Œã°ãªã‚‰ãªã„
  - æœ¬ä½“ã®å¤‰æ•°ã®æ‰€æœ‰æ¨©ãŒã»ã‹ã«ç§»ã£ãŸå ´åˆã€ãã®å‚ç…§ã¯ã‚‚ã¯ã‚„ä½¿ãˆãšã‚¨ãƒ©ãƒ¼ã«ãªã‚‹

## Slice

Slice ã¨ã¯ã€String ã‚„ Array ã®ä¸€éƒ¨åˆ†ã«å¯¾ã™ã‚‹å‚ç…§ã§ã€ä»¥ä¸‹ã® 2 ç¨®é¡ãŒã‚ã‚‹ã€‚

- String Slice
  - å‹ã¯`&str`
  - ãªãŠã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«(`"hello"`ãªã©)ã¯åˆã‚ã‹ã‚‰ String Slice(`&str`)ã§ã‚ã‚‹
- Array Slice
  - å‹ã¯`&[T]`

```rust
// String Slice
let my_string: String = "hello world".to_string();
let my_string_slice: &str = &my_string[1..5];
println!("{}", my_string_slice); // -> 'ello'

// Array Slice
let numbers = [1, 2, 3, 4, 5];
let numbers_slice: &[i32] = &numbers[1..3];
println!("{:?}", numbers_slice); // -> [2, 3]
```

## Struct / æ§‹é€ ä½“

```rust
struct User {
    username: String,
    sign_in_count: u32,
}

const shota = User {
    username: String::from("shota"),
    sign_in_count: 23,
}
```

TS ã§ãŠãªã˜ã¿ã®çœç•¥è¨˜æ³•ã‚‚ä½¿ãˆã‚‹

```rust
let default_user = User { /* çœç•¥ */ };
let user = User {
    username, // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£åã¨è¨­å®šã—ãŸã„å¤‰æ•°åãŒåŒã˜å ´åˆã¯çœç•¥ã§ãã‚‹
    ..default_user, // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ã„ãŸã„å ´åˆã¯ã“ã†ã™ã‚‹
}
```

æ§‹é€ ä½“ã‚’ãƒ—ãƒªãƒ³ãƒˆã™ã‚‹ã«ã¯ Debug ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚‹

```rust
#[derive(Debug)]
struct User { /* */ }

let user = Rectangle { /* */ };
println!("rect is {:?}", rect);
```

### ãƒ¡ã‚½ãƒƒãƒ‰(instance ãƒ¡ã‚½ãƒƒãƒ‰)ã¨é–¢é€£é–¢æ•°(â‰’static ãƒ¡ã‚½ãƒƒãƒ‰)

```rust
impl Rectangle {
  // ãƒ¡ã‚½ãƒƒãƒ‰(selfã‚’ã¨ã‚‹)
  fn can_hold(&self, other: &Rectangle) -> bool {
    self.width > other.width && self.height > other.height
  }

  // é–¢é€£é–¢æ•°(selfã‚’å–ã‚‰ãªã„)
  fn square(size: isize) -> Rectangle {
    Rectangle {
      width: size,
      height: size,
    }
  }
}
```

### ç‰¹æ®Šãªæ§‹é€ ä½“

- Tuple æ§‹é€ ä½“
  - æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åè‡ªä½“ã«ã¯ã•ã»ã©æ„å‘³ãŒãªã„ã‚ˆã†ãªã¨ãã«ä½¿ã†

```rust
struct Ipv4(u8, u8, u8, u8);
let address = Ipv4(192, 168, 1, 100);
```

- Unit-like æ§‹é€ ä½“
  - æ§‹é€ ä½“ã«å€¤ãŒã¾ã£ãŸããªã„ã¨ãã‚„ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ã§å½¹ç«‹ã¤ï¼Ÿè©³ç´°ä¸æ˜

## Enum

åŸºæœ¬

```rust
// å®šç¾©
enum IpAddrKind {
    V4,
    V6,
}

// ä»£å…¥
let maybe_ip_v4 = IpAddrKind::V4;

// æ´»ç”¨ä¾‹
match maybe_ip_v4 {
    IpAddrKind::V4 => println!("v4ã§ã™"),
    IpAddrKind::V6 => println!("v6ã§ã™"),
}
```

å€¤ã‚’æŒãŸã›ãŸã‚Šã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```rust
enum SampleEnum {
    Quit,
    Position { x: i32, y: i32 },
    Message(String),
    Color(i32, i32, i32),
}

impl SampleEnum {
    fn output_message(self: &Self) -> String {
        match self {
            SampleEnum::Message(str) => "Message is: ".to_string() + str,
            _ => "other".to_string(),
        }
    }
}

let s = SampleEnum::Message("hello!".to_string());

println!("{}", s.output_message()) // -> `Message is hello!`
```

### Option å‹

Null ã«ãªã‚Šã†ã‚‹å€¤ã¯ Option å‹ã¨ã—ã¦ä½¿ã†å¿…è¦ãŒã‚ã‚‹ã€‚Option, Some åŠã³ None ã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€æ¥é ­å­ãªã—ã§ä½¿ç”¨ã§ãã‚‹ã€‚

```rust
// Optionå‹ã®å®šç¾©
enum Option<T> {
    Some(T),
    None,
}

// ä½¿ã„æ–¹ã®ä¾‹
let mut maybe_number: Option<i32>;
maybe_number = None;
maybe_number = Some(5);
```

## match

åŸºæœ¬å½¢

```rust
enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter(String),
}

fn value_in_cents(coin: Coin) -> u32 {
  match coin {
    Coin::Penny => 1,
    Coin::Nickel => 5,
    Coin::Dime => 10,
    Coin::Quarter(state) => { // å€¤ã‚’æŒã¤Enumã®å ´åˆã¯ã“ã®ã‚ˆã†ã«å–ã‚Šå‡ºã›ã‚‹
      println!("{}", state);
      25
    }
  }
}
```

Option ã¨ã®çµ„ã¿åˆã‚ã›

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
```

### if let

`match`ã§ç‰¹å®šã®ã‚±ãƒ¼ã‚¹ã ã‘å–ã‚Šæ‰±ã„ãŸã„å ´åˆã¯ã€`if let`ã‚’ä½¿ã†ã“ã¨ã‚‚æ¤œè¨ã™ã‚‹ã¨è‰¯ã„ã€‚

```rust
let mut count = 0;
match coin {
    // {:?}å·ã®ã‚¯ã‚©ãƒ¼ã‚¿ãƒ¼ã‚³ã‚¤ãƒ³
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}

// ã“ã‚Œã¯ä¸‹è¨˜ã®ã‚ˆã†ã«ã‚‚æ›¸ã‘ã‚‹

let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
```

## Packages, Crates, and Modules

### Packages, Crates

- package
  - ä¸€ã¤ä»¥ä¸Šã® crate ã§æ§‹æˆã•ã‚Œã‚‹ã€‚crate ã®æ•°ã®è¦ä»¶ã¯ä»¥ä¸‹ã®é€šã‚Šã€‚
    - å°‘ãªãã¨ã‚‚ï¼‘ã¤ä»¥ä¸Šã® crate ãŒå¿…è¦
    - library crate ã¯ 0 ã¾ãŸã¯ 1 ã¤ã ã‘
    - binary crate ã¯ã„ãã¤ã§ã‚‚
  - ãªã‚“ã‚‰ã‹ã®ã¾ã¨ã¾ã£ãŸæ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹
  - `cargo.toml`ã‚’å«ã‚€ã€‚ã“ã“ã«ã¯ crate ã®ãƒ“ãƒ«ãƒ‰æ–¹æ³•ãŒæ›¸ã‹ã‚Œã¦ã„ã‚‹
- crate
  - library crate åˆã¯ binary crate ã®ã“ã¨
- crate root
  - ä¸‹è¨˜ã®ã„ãšã‚Œã‹
    - `src/lib.rs`(library crate)
      - ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åãŒ crate åã«ãªã‚‹
    - `src/main.rs`(binary crate)
      - ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åãŒ crate åã«ãªã‚‹
    - `src/bin/**.rs`(binary crate)
  - ãã® crate ã® root module ã«ãªã‚‹
  - ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒèª­ã¿è¾¼ã¿ã‚’ã‚¹ã‚¿ãƒ¼ãƒˆã™ã‚‹åœ°ç‚¹

### Modules

- ã‚¯ãƒ¬ãƒ¼ãƒˆå†…ã§ã‚³ãƒ¼ãƒ‰ã‚’ã‚°ãƒ«ãƒ¼ãƒ”ãƒ³ã‚°ã™ã‚‹ãŸã‚ã«ä½¿ã†
- å¯èª­æ€§ã¨å†åˆ©ç”¨å¯èƒ½æ€§ã‚’å‘ä¸Šã•ã›ã‚‹ãŸã‚ã«ä½¿ã†
- ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã«ä½¿ã†
  - Public --- ã‚³ãƒ¼ãƒ‰ã®å¤–ã§ã‚‚ä½¿ãˆã‚‹
  - Private --- ã‚³ãƒ¼ãƒ‰ã®å¤–ã§ã¯ä½¿ãˆãªã„

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

ä¸Šè¨˜ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’ crate root ã«å®šç¾©ã—ãŸå ´åˆã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ„ãƒªãƒ¼ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹

```
crate(æš—é»™çš„ã«å‘½åã•ã‚Œã‚‹)
 â””â”€â”€ front_of_house
     â”œâ”€â”€ hosting
     â”‚   â”œâ”€â”€ add_to_waitlist
     â”‚   â””â”€â”€ seat_at_table
     â””â”€â”€ serving
         â”œâ”€â”€ take_order
         â”œâ”€â”€ serve_order
         â””â”€â”€ take_payment
```

### Path

- ãƒ‘ã‚¹ã®ç¨®é¡
  - Absolute path --- crate name åˆã¯`crate`ã®ãƒªãƒ†ãƒ©ãƒ«ã‹ã‚‰å§‹ã¾ã‚‹
  - Relative path --- `self`ã€`super`åˆã¯åŒä¸€ãƒ¬ãƒ™ãƒ«ã«ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‹ã‚‰å§‹ã¾ã‚‹
- `::`ã§åŒºåˆ‡ã‚‹
- Private ã¨ Public ã®ç®¡ç†
  - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ï¼š
    - å‘¼ã³å‡ºã—ãŸé–¢æ•°ã¨åŒä¸€ãƒ¬ãƒ™ãƒ«ã«ã‚ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯`pub`ãªã—ã§ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
    - å­ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚„ãã®å†…éƒ¨ã¯ Privateã€‚ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã«ã™ã‚‹ã«ã¯`pub mod`ã‚„`pub fn`ãªã©ãŒå¿…è¦ã€‚
    - è¦ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ Public

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```

`super`ã‚’ä½¿ã†ã¨è¦ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹

```rust
fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
```

struct ã®è¦ç´ ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§éå…¬é–‹

```rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        // ã“ã®é–¢æ•°ãªã—ã§ã¯Breakfastã¯åˆæœŸåŒ–ã™ã‚‰ã§ããªã„
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // å¤‰æ›´å¯èƒ½
    meal.toast = String::from("Wheat");

    // ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ä¸å¯
    meal.seasonal_fruit = String::from("blueberries");
}
```

ä¸€æ–¹ã€enum ã®è¦ç´ ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§å…¬é–‹

```rust
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
```

### use

ä¸‹è¨˜ã®ã‚ˆã†ã«ã™ã‚‹ã¨ã€ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ¥é ­è©ç„¡ã—ã§ã¤ã‹ãˆã‚‹ã€‚

```rust
use crate::front_of_house::hosting;

// - çµ¶å¯¾ãƒ‘ã‚¹ã§ã‚‚ç›¸å¯¾ãƒ‘ã‚¹ã§ã‚‚OK
// - ä»¥é™ã€`hosting::***`ã®ã‚ˆã†ã«ä½¿ãˆã‚‹
```

æ…£ä¾‹ã¨ã—ã¦ã€é–¢æ•°ã¯ã²ã¨ã¤ä¸Šã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’èª­ã¿è¾¼ã‚€ã€‚ã“ã‚Œã¯ã€é–¢æ•°ãŒãƒ­ãƒ¼ã‚«ãƒ«ã®ã‚‚ã®ã§ã¯ãªã„ã“ã¨ã‚’æ˜ç¢ºã«ã™ã‚‹ãŸã‚ã€‚

```rust
use crate::front_of_house::hosting;
hosting::add_to_waitlist();
```

æ…£ä¾‹ã¨ã—ã¦ã€Enum ã®å ´åˆã¯ãã‚Œè‡ªèº«ã‚’èª­ã¿è¾¼ã‚€ã€‚ç‰¹ã«ç†ç”±ã¯ãªã„ã€‚

```rust
use std::collections::HashMap;
let mut map = HashMap::new();
```

ä¾‹å¤–ã¨ã—ã¦ã€åå‰ãŒé‡è¤‡ã™ã‚‹å ´åˆã¯ãã®ã²ã¨ã¤ä¸Šã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚€ã€‚

```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {...}
fn function2() -> io::Result {...}
```

ã‚‚ã—ãã¯ä¸‹è¨˜ã®ã‚ˆã†ã«åˆ¥åã‚’ã¤ã‘ã‚‹ã€‚

```rust
use std::io::Result as IoResult;
```

`pub use`ã¨ã™ã‚‹ã¨å†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã§ãã‚‹ã€‚

```rust
// å¤–éƒ¨ã®ã‚³ãƒ¼ãƒ‰ã‹ã‚‰`hosting`ã‚’å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ãªã‚‹
pub use crate::front_of_house::hosting;
```

å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã„ãŸã„ã¨ãã¯ã€`Cargo.toml`ã«è¨˜è¼‰ã—ãŸã†ãˆã§`use`ã™ã‚‹ã€‚

```toml
[dependencies]
rand = "0.8.3"
```

```rust
// TODO: traitã£ã¦ãªã«ï¼Ÿï¼Ÿ Rng.***ã§ã¯ãªã„ã®ã‹ï¼Ÿ
use rand::Rng;
let rng = rand::thread_rng()
```

çœç•¥è¨˜æ³•

```rust
use std::io;
use std::io::Write;
use std::io::Read;

// ä¸Šè¨˜ã¯ä¸‹è¨˜ã®é€šã‚Šæ›¸ã‘ã‚‹
use std::io::{self, Write, Read}
```

glob operator ã‚‚ä½¿ãˆã‚‹ãŒã€åŸºæœ¬çš„ã«ãƒ†ã‚¹ãƒˆã§ã®ã¿ä½¿ç”¨ã™ã‚‹ã“ã¨ã€‚è¦‹é€šã—ãŒæ‚ªããªã‚‹ãŸã‚ã€‚

```rust
use std::collections::*;
```

### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«åˆ‡ã‚Šå‡ºã™

`mod`ã®ã‚ã¨ã«ãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¨˜è¼‰ã™ã‚‹ã“ã¨ã§ã€ãã®ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã›ã‚‹ã€‚

```rust
// src/front_of_house.rs
pub mod hosting {
  pub fn add_to_waitlist() {}
}
```

```rust
// src/lib.rs
mod front_of_house;
front_of_house::hosting::add_to_waitlist();
```

## Collections

- äºˆã‚ç”¨æ„ã•ã‚Œã¦ã„ã‚‹ä¾¿åˆ©ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ã“ã¨
- è¤‡æ•°ã®å€¤ã‚’ä¿æŒã§ãã‚‹ã®ãŒç‰¹å¾´
- Array ã‚„ Tuple ã¨ç•°ãªã‚Šã€ãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªã«ä¿æŒã•ã‚Œã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚µã‚¤ã‚ºã‚’ç¢ºå®šã•ã›ãªãã¦ã‚‚ã„ã„

### Vector

- å˜ä¸€å‹ã§ã‚ã‚‹
- è¤‡æ•°ã®å€¤ã‚’ä¿æŒã§ãã‚‹
- å¯å¤‰é•·ã§ã‚ã‚‹
- `Vec<T>`

```rust
// åˆæœŸå€¤ãŒãªã„å ´åˆ
let v: Vec<i32> = Vec::new();

// åˆæœŸå€¤ãŒã‚ã‚‹å ´åˆï¼ˆãƒã‚¯ãƒ­ã‚’ä½¿ã£ã¦åˆæœŸåŒ–ã§ãã‚‹ï¼‰
let v = vec![1, 2, 3];
```

å€¤ã®è¿½åŠ 

```rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

å€¤ã®å–å¾—ã«ã¯ï¼’ç¨®é¡ã®æ–¹æ³•ãŒã‚ã‚‹ã€‚ã„ãšã‚Œã‚‚å‚ç…§ã‚’å–å¾—ã™ã‚‹ã€‚

```rust
// çµæœã‚’&Tã¨ã—ã¦å—ã‘å–ã‚‹
// å­˜åœ¨ã—ãªã‘ã‚Œã°ãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚‹
let third = &v[2];

// çµæœã‚’Option<&T>ã¨ã—ã¦å—ã‘å–ã‚‹
// å­˜åœ¨ã—ãªã‘ã‚Œã°Noneã‚’è¿”ã—ã€å­˜åœ¨ã™ã‚Œã°Some(&T)ã‚’è¿”ã™ã€‚
let third = v.get(2);
```

åå¾©å‡¦ç†

```rust
// å‚ç…§ã®ã¿
let v = vec![1,2,3];
for i in &v {
  println!("{}", i);
}

// å¤‰æ›´ã‚ã‚Š
let mut v = vec![1,2,3];
for i in &mut v {
  // Dereference operatorã‚’ä½¿ã†
  *i += 50;
}
```

ç•°ãªã‚‹å‹ã‚’ Vector ã«ä¿å­˜ã—ãŸã„å ´åˆã¯ã€äºˆã‚ Enum ã¨ã—ã¦ä½œæˆã—ã¦ãŠãã“ã¨ã§å¯¾å¿œã™ã‚‹ã€‚

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

### String

String ã¨ã¯ï¼Ÿ

- String literal(`str`)
  - rust ã§å”¯ä¸€ã®çµ„ã¿è¾¼ã¿ã®æ–‡å­—åˆ—å‹
  - string slice(`&str`)ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹ã€‚ãªãœãªã‚‰ã€æ–‡å­—åˆ—è‡ªä½“ã¯ãƒã‚¤ãƒŠãƒªã«çµ„ã¿è¾¼ã¾ã‚Œã‚‹å®Œå…¨ã«å¤‰æ›´ä¸å¯èƒ½ãªã‚‚ã®ã§ã‚ã‚Šã€String literal ã¯ãã“ã¸ã®å‚ç…§ã¨ã—ã¦ã—ã‹å­˜åœ¨ã§ããªã„ã‹ã‚‰ã€‚
- String type(`String`)
  - ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã‚Šæä¾›ã•ã‚Œã‚‹
  - æ‹¡å¼µã€å¤‰æ›´ã€æ‰€æœ‰ãŒå¯èƒ½

rust ã®ä¸–ç•Œã§'String'ã¨è¨€ã£ãŸå ´åˆã€String type åˆã¯ String slice ã‚’æŒ‡ã™ã“ã¨ãŒå¤šã„ã€‚ã©ã¡ã‚‰ã‚‚ UTF-8ã€‚

String ã®ä½œã‚Šæ–¹

```rust
let s = "aaa".to_string();
let s = String::from("aaa");
```

æœ«å°¾ã«æ–‡å­—åˆ—ã‚’è¿½åŠ ã™ã‚‹ã€‚ãªãŠã€`push_str()`ã¯å‚ç…§(string literal)ã‚’å¼•æ•°ã¨ã—ã¦å–ã‚‹ã®ã§ã€æ‰€æœ‰æ¨©ã®ç§»è»¢ã¯ç™ºç”Ÿã—ãªã„ã€‚

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

æ–‡å­—åˆ—ã®çµåˆ(+ã‚’ä½¿ã†æ–¹æ³•)

- `s1`ã®æ‰€æœ‰æ¨©ã¯ s ã«ç§»ã‚‹ã€‚å†åˆ©ç”¨ã•ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã€‚å°‘ã—åŠ¹ç‡çš„ã€‚
- `+`ã«ä¸ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã¯`&str`å‹ã€‚ãªãŠã€`&String`ã¯è‡ªå‹•çš„ã«å¤‰æ›ã•ã‚Œã‚‹ã€‚deref coercion ã¨ã„ã†ã€‚

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
```

æ–‡å­—åˆ—ã®çµåˆ(`format!`ã‚’ä½¿ã†æ–¹æ³•)

- ã“ã®å ´åˆã¯æ‰€æœ‰æ¨©ã®ç§»è»¢ã¯ä¸€åˆ‡ç™ºç”Ÿã—ãªã„ã€‚

```rust
let s = format!("{}-{}-{}", s1, s2, s3);
```

UTFâˆ’8 ã®è©±

- rust ã®å†…éƒ¨ã§ã¯æ–‡å­—åˆ—ã¯ byte(`vec<u8>`)ã§ã¨ã—ã¦ä¿æŒã•ã‚Œã¦ã„ã‚‹

```rust
// è¡¨ç¾ã—ãŸã„æ–‡å­—åˆ—
"à¤¨à¤®à¤¸à¥à¤¤à¥‡"

// byteã§è¡¨ã™
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]

// Unicode scalar value(ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ)ã§è¡¨ã™
['à¤¨', 'à¤®', 'à¤¸', 'à¥', 'à¤¤', 'à¥‡']

// grapheme clusters(äººé–“ãŒç›®ã«ã™ã‚‹æ–‡å­—)ã§è¡¨ã™
["à¤¨", "à¤®", "à¤¸à¥", "à¤¤à¥‡"]
```

ã©ã†ã—ã¦ã‚‚å¿…è¦ãªã‚‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ã†ã“ã¨ã‚‚å¯èƒ½ã§ã¯ã‚ã‚‹ãŒã€ã‚ã¾ã‚Šã„ã„ã‚¢ã‚¤ãƒ‡ã‚¢ã§ã¯ãªã„ã€‚ãªãŠã€ä¸­é€”åŠç«¯ãªä½ç½®ã§åˆ‡ã‚‹ã¨ãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚‹ã®ã§è¦æ³¨æ„ã€‚

```rust
let s1 = "ã“ã‚“ã¡ã‚".to_string();
let s = &s1[0..3]; // sã¯&strã«ãªã‚‹("ã“")
```

ç¹°ã‚Šè¿”ã—

```rust
// Unicodeã‚¹ã‚«ãƒ©å€¤ã¨ã—ã¦å–ã‚Šå‡ºã—ã¦ç¹°ã‚Šè¿”ã™
for c in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".chars() {}

// byteã¨ã—ã¦å–ã‚Šå‡ºã—ã¦ç¹°ã‚Šè¿”ã™
for b in "à¤¨à¤®à¤¸à¥à¤¤à¥‡".bytes() {}

// graphene clustersã§å–ã‚Šå‡ºã—ã¦ç¹°ã‚Šè¿”ã™ã«ã¯å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå¿…è¦
```

### Hash Map

ä½œæˆ

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```

è¤‡æ•°ã® vector ã‚’ zip ã—ã¦ä½œæˆã™ã‚‹ã“ã¨ã‚‚ã§ãã‚‹

```rust
let teams = vec![
  String::from("Blue"),
  String::from("Yellow")
];
let initial_scores = vec![
  10,
  50,
];
let scores: HashMap<_, _> =
    teams.into_iter().zip(initial_scores.into_iter()).collect();
```

å€¤ã®å–å¾—(Option å‹ãŒå¾—ã‚‰ã‚Œã‚‹)

```rust
let score = scores.get("Blue");
```

ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

```rust
for (key, value) in &scores {}
```

å€¤ã®æ›´æ–°

```rust
let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

// ä¸Šæ›¸ã
scores.insert(String::from("Blue"), 25);

// æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦ä¸Šæ›¸ã
let count = scores.entry("Blue").or_insert(0);
*count += 1;

// å€¤ãŒãªã‘ã‚Œã°æŒ¿å…¥ã€ã‚ã‚Œã°ä½•ã‚‚ã—ãªã„
scores.entry(String::from("Blue")).or_insert(50);
```

## ã‚¨ãƒ©ãƒ¼

rust ã«ã¯ 2 ç¨®é¡ã®ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚‹ã€‚ä»–ã®è¨€èªã§ã¯ã“ã‚Œã‚‰ã¯åŒºåˆ¥ã•ã‚Œãªã„ã“ã¨ãŒå¤šã„ã€‚

- recoverable ãªã‚¨ãƒ©ãƒ¼
  - `Result<T, E>`å‹
  - ä¾‹ï¼‰ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆ
- unrecoverable ãªã‚¨ãƒ©ãƒ¼
  - `panic!`ãƒã‚¯ãƒ­
  - ä¾‹ï¼‰Array ã®ç¯„å›²å¤–ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸå ´åˆ

### panic!

- [ã‚³ãƒ©ãƒ ] ãƒã‚¤ãƒŠãƒªã‚µã‚¤ã‚ºã‚’å¯èƒ½ãªé™ã‚Šå°ã•ãã—ãŸã„å ´åˆã¯`Unwinding`ã‚’`abort`ã«å¤‰æ›´ã™ã‚‹([å‚è€ƒ](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html#unwinding-the-stack-or-aborting-in-response-to-a-panic))

```toml
[profile] # ãƒªãƒªãƒ¼ã‚¹ç’°å¢ƒãªã‚‰profile.release
panic = 'abort'
```

- Backtrace ã‚’å–å¾—ã™ã‚‹ã«ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹ã€‚

```sh
RUST_BACKTRACE=1 cargo run
```

### Result

- ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’æ­¢ã‚ã‚‹ã¾ã§ã‚‚ãªã„ã‚¨ãƒ©ãƒ¼ã®å ´åˆã€`Result`å‹ãŒä½¿ã‚ã‚Œã‚‹ã€‚
- `Result`, `Ok`, `Err`ã¯ prelude ã«ã‚ˆã‚Šç”¨æ„ã•ã‚Œã‚‹ã®ã§ã€æ¥é ­å­ã‚’ã¤ã‘ãšã«ä½¿ãˆã‚‹ã€‚

```rust
// Resultå‹ã®å®šç¾©
enum Reeult<T, E> {
  Ok(T),
  Err(E),
}
```

å‡¦ç†çµæœã‚’ç¢ºèªã—ã¦ã€ä»¥é™ã®å‡¦ç†ã‚’åˆ†å²ã™ã‚‹æ–¹æ³•

```rust
use std::fs::File;
let f = File::open("hello.txt");

let f = match f {
  Ok(file) => file,
  Err(error) => panic!("{:?}", error),
};
```

ã€ŒæˆåŠŸã—ãŸå ´åˆã¯å€¤ã‚’å–å¾—ã—ã€å¤±æ•—ã—ãŸå ´åˆã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã™ã‚‹ã€ã¨ã„ã†å‡¦ç†ã¯å®šå‹çš„ã§ã‚ã‚‹ãŸã‚ã€`unwrap()`ã‚„`expect()`ã¨ã„ã†é–¢æ•°ã‚’ä½¿ã£ã¦çŸ­ç¸®ã§ãã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã€‚

```rust
let f = File::open("hello.txt").unwrap();

// expectã¯unwrapã¨åŒã˜ã ãŒã€ã‚ã‹ã‚Šã‚„ã™ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒã§ãã‚‹
let f = File::open("hello.txt").expect("Failed to open hello.txt");

```

ã‚ˆã‚Šè¤‡é›‘ãªå ´åˆåˆ†ã‘ã«ã¯ãƒãƒƒãƒã‚¬ãƒ¼ãƒ‰ã‚’ä½¿ã†

```rust
let f = match f {
  Ok(file) => file,
  // if... ã®éƒ¨åˆ†ãŒãƒãƒƒãƒã‚¬ãƒ¼ãƒ‰
  // refã®æ„å‘³ã¯ã‚ˆã†ã‚ã‹ã‚‰ã‚“
  Err(ref error) if error.kind() == ErrorKind::NotFound => match File::create("hello.txt") {
    Ok(fc) => fc,
    Err(e) => {
      panic!("Tried to create file but there was a problem: {:?}", e)
    }
  },
  Err(error) => {
    panic!("There was a problem opening the file: {:?}", error)
  }
};
```

Tips: å‹ã‚’èª¿ã¹ãŸã„ã¨ãã¯ã€å…¨ç„¶é•ã†å‹ã«ä»£å…¥ã—ã¦æ„å›³çš„ã«ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã—ã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ç¢ºèªã™ã‚‹

```rust
let f: u32 = File::open("hello.txt");
// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ => found enum `Result<File, std::io::Error>`
```

ã‚¨ãƒ©ãƒ¼ã®å‡¦ç†ã‚’é–¢æ•°ã®å‘¼ã³å‡ºã—å…ƒã«ã¾ã‹ã›ã‚‹ï¼ˆ**ã‚¨ãƒ©ãƒ¼ã®å§”è­²**ï¼‰ã«ã¯ã€é–¢æ•°ã®è¿”ã‚Šå€¤ã®å‹ã‚’ Result ã«ã™ã‚‹ã€‚

```rust
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let f = File::open("hello.txt");

    let mut f = match f {
        Ok(file) => file,
        // ã‚¨ãƒ©ãƒ¼ã‚’å‘¼ã³å‡ºã—å…ƒã«è¿”ã™
        Err(e) => return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&mut s) {
        Ok(_) => Ok(s),
        // ã‚¨ãƒ©ãƒ¼ã‚’å‘¼ã³å‡ºã—å…ƒã«è¿”ã™
        Err(e) => Err(e),
    }
}
```

ã€ŒæˆåŠŸã—ãŸå ´åˆã¯å€¤ã‚’å–å¾—ã—ã€å¤±æ•—ã—ãŸã¨ãã¯å‘¼ã³å‡ºã—å…ƒã«ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚’å§”è­²ã™ã‚‹ã€ã“ã¨ã¯å®šå‹çš„ãªå‡¦ç†ã§ã‚ã‚‹ãŸã‚ã€`?`æ¼”ç®—å­ã‚’ä½¿ã£ã¦ç°¡æ½”ã«è¨˜è¼‰ã§ãã‚‹æ§˜ã«ãªã£ã¦ã„ã‚‹ã€‚

```rust
fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    // ?ã¨æ›¸ãã ã‘ã§ã‚¨ãƒ©ãƒ¼ã®å§”è­²ã‚’è¡Œãˆã‚‹
    let mut f = File::open("hello.txt")?;
    f.read_to_string(&mut s)?;

    // åˆã¯é€£çµã—ã¦ä¸€æ–‡ã§æ›¸ãã“ã¨ã‚‚å¯èƒ½
    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
```

### panic ã¨ Result ã®ä½¿ã„åˆ†ã‘æ–¹

- ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã”ã¨ã®ä½¿ã„åˆ†ã‘
  - ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã€ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã‚³ãƒ¼ãƒ‰ã€ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®å ´åˆ
    - panic(unwrap, expect) ãŒæœ€é©ã€‚
    - æ„å›³ãŒæ˜ç¢ºã«ãªã‚‹ãŸã‚ã€‚ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’é©åˆ‡ã«å¤±æ•—ã•ã›ã‚‹ãŸã‚ã€‚
  - é–‹ç™ºè€…ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚ˆã‚Šã‚‚æƒ…å ±ã‚’æŒã£ã¦ãŠã‚Šã€æ­£ã—ã•ã‚’ç¢ºä¿¡ã§ãã‚‹å ´åˆ
    - ä¾‹ãˆã°ã€ä¸‹è¨˜ã¯å¸¸ã«æ­£ã—ã„ã®ã§ panic ã—ã¦ã‚ˆã„ã€‚
      ```rust
      let home: IpAddr = "127.0.0.1".parse().unwrap();
      ```
    - é€†ã«ã€IP ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒãƒ¦ãƒ¼ã‚¶å…¥åŠ›ç­‰ã§ä¸ãˆã‚‰ã‚Œã‚‹å ´åˆã¯ Result ã‚’ä½¿ã£ã¦å‡¦ç†ã™ã‚‹ã€‚

ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

- ãƒ‘ãƒ‹ãƒƒã‚¯ãŒæœ€é©
  - æ‚ªã„çŠ¶æ…‹(å‰æã€ä¿è¨¼ã€å¥‘ç´„ã€ä¸å¤‰æ€§ãŒç ´ã‚‰ã‚ŒãŸçŠ¶æ…‹)ã§ã‚ã‚‹ã€ã‹ã¤ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã‚’æº€ãŸã™å ´åˆ
    - ãã®æ‚ªã„çŠ¶æ…‹ãŒçµ¶å¯¾ã«èµ·ãã¦ã¯ãªã‚‰ãªã„ã“ã¨ã§ã‚ã‚‹
    - ãã®æ™‚ç‚¹ä»¥é™ã€è‰¯ã„çŠ¶æ…‹ã§ã‚ã‚‹ã“ã¨ã‚’å‰æã«ã‚³ãƒ¼ãƒ‰ãŒæ›¸ã‹ã‚Œã¦ã„ã‚‹
    - å‹ã‚’ä½¿ã£ã¦å•é¡Œã®ç™ºç”Ÿã‚’é˜²ãæ–¹æ³•ãŒãªã„
- Result ãŒæœ€é©
  - å¤±æ•—ãŒäºˆæƒ³ã•ã‚Œã‚‹ã¨ã(HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆãªã©)

å‹ã‚’ä½¿ã£ã¦å€¤ãŒæ­£ã—ã„ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã«ã¯ã€ä¸‹è¨˜ã®ã‚ˆã†ãª Constructor ã¨ Getter ã‚’ä½¿ã†ã€‚ä¸‹è¨˜ã§ã¯å€¤ãŒ 1 ã‹ã‚‰ 100 ã®é–“ã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ã¦ã„ã‚‹ã€‚

```rust
pub struct Guess {
    // ã“ã®å€¤ã¯åŸºæœ¬çš„ã«éå…¬é–‹ã€‚ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã—ã¦å‘¼ã³å‡ºã•ã‚Œã‚‹å ´åˆã€‚
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Value must be between 1 and 100, got {}.", value);
        }

        Guess {
            value
        }
    }

    pub fn value(&self) -> u32 {
        self.value
    }
}
```
